[{"title":"使用sklearn进行数据预处理 —— 归一化/标准化/正则化","date":"2017-02-18T15:23:34.000Z","path":"2017/02/18/使用sklearn进行数据预处理 —— 归一化-标准化-正则化/","text":"本文主要是对照scikit-learn的preprocessing章节结合代码简单的回顾下预处理技术的几种方法，主要包括标准化、数据最大最小缩放处理、正则化、特征二值化和数据缺失值处理。内容比较简单，仅供参考！ 首先来回顾一下下面要用到的基本知识。 ## 一、知识回顾 均值公式： \\[\\bar{x}=\\frac{1}{n}\\sum_{i=1}^{n}x_{i}\\] 方差公式： \\[s^{2}=\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{2}\\] 0-范数，向量中非零元素的个数。 1-范数： \\[||X||=\\sum_{i=1}^{n}|x_{i}|\\] 2-范数： \\[||X||_{2}=(\\sum_{i=1}^{n}x_{i}^{2})^{\\frac{1}{2}}\\] p-范数的计算公式： \\[||X||_{p}=(\\sum_{i=1}^{n}x_{i}^{p})^{\\frac{1}{p}}\\] 数据标准化：当单个特征的样本取值相差甚大或明显不遵从高斯正态分布时，标准化表现的效果较差。实际操作中，经常忽略特征数据的分布形状，移除每个特征均值，划分离散特征的标准差，从而等级化，进而实现数据中心化。 二、标准化(Standardization)，或者去除均值和方差进行缩放 公式为：(X-X_mean)/X_std 计算时对每个属性/每列分别进行. 将数据按其属性(按列进行)减去其均值，然后除以其方差。最后得到的结果是，对每个属性/每列来说所有数据都聚集在0附近，方差值为1。 首先说明下sklearn中preprocessing库里面的scale函数使用方法： 1sklearn.preprocessing.scale(X, axis=0, with_mean=True, with_std=True, copy=True) 根据参数的不同，可以沿任意轴标准化数据集。 参数解释： X：数组或者矩阵 axis：int类型，初始值为0，axis用来计算均值 means 和标准方差 standard + deviations. 如果是0，则单独的标准化每个特征（列），如果是1，则标准化每个观测样本（行）。 with_mean: boolean类型，默认为True，表示将数据均值规范到0 with_std: boolean类型，默认为True，表示将数据方差规范到1 一个简单的例子 假设现在我构造一个数据集X，然后想要将其标准化。下面使用不同的方法来标准化X： 方法一：使用sklearn.preprocessing.scale()函数 方法说明： X.mean(axis=0)用来计算数据X每个特征的均值； X.std(axis=0)用来计算数据X每个特征的方差； preprocessing.scale(X)直接标准化数据X。 将代码整理到一个文件中： 12345678910111213from sklearn import preprocessing import numpy as np X = np.array([[ 1., -1., 2.], [ 2., 0., 0.], [ 0., 1., -1.]]) # calculate mean X_mean = X.mean(axis=0) # calculate variance X_std = X.std(axis=0) # standardize X X1 = (X-X_mean)/X_std # use function preprocessing.scale to standardize X X_scale = preprocessing.scale(X) 最后X_scale的值和X1的值是一样的，前面是单独的使用数学公式来计算，主要是为了形成一个对比，能够更好的理解scale()方法。 方法2：sklearn.preprocessing.StandardScaler类 该方法也可以对数据X进行标准化处理，实例如下： 1234567from sklearn import preprocessing import numpy as np X = np.array([[ 1., -1., 2.], [ 2., 0., 0.], [ 0., 1., -1.]]) scaler = preprocessing.StandardScaler() X_scaled = scaler.fit_transform(X) 这两个方法得到最后的结果都是一样的。 三、将特征的取值缩小到一个范围（如0到1） 除了上述介绍的方法之外，另一种常用的方法是将属性缩放到一个指定的最大值和最小值(通常是1-0)之间，这可以通过preprocessing.MinMaxScaler类来实现。 使用这种方法的目的包括： 1、对于方差非常小的属性可以增强其稳定性； 2、维持稀疏矩阵中为0的条目。 下面将数据缩至0-1之间，采用MinMaxScaler函数 1234567from sklearn import preprocessing import numpy as np X = np.array([[ 1., -1., 2.], [ 2., 0., 0.], [ 0., 1., -1.]]) min_max_scaler = preprocessing.MinMaxScaler() X_minMax = min_max_scaler.fit_transform(X) 最后输出： 123array([[ 0.5 , 0. , 1. ], [ 1. , 0.5 , 0.33333333], [ 0. , 1. , 0. ]]) 测试用例： 1234X_test = np.array([[ -3., -1., 4.]]) X_test_minmax = min_max_scaler.transform(X_test) X_test_minmax array([[-1.5 , 0. , 1.66666667]]) 注意：这些变换都是对列进行处理。 当然，在构造类对象的时候也可以直接指定最大最小值的范围：feature_range=(min, max)，此时应用的公式变为： 12X_std=(X-X.min(axis=0))/(X.max(axis=0)-X.min(axis=0)) X_minmax=X_std/(X.max(axis=0)-X.min(axis=0))+X.min(axis=0)) 四、正则化(Normalization) 正则化的过程是将每个样本缩放到单位范数(每个样本的范数为1)，如果要使用如二次型(点积)或者其它核方法计算两个样本之间的相似性这个方法会很有用。 该方法是文本分类和聚类分析中经常使用的向量空间模型（Vector Space Model)的基础. Normalization主要思想是对每个样本计算其p-范数，然后对该样本中每个元素除以该范数，这样处理的结果是使得每个处理后样本的p-范数(l1-norm,l2-norm)等于1。 方法1：使用sklearn.preprocessing.normalize()函数 12345678&gt;&gt;&gt; X = [[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]] &gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm='l2') &gt;&gt;&gt; X_normalized array([[ 0.40..., -0.40..., 0.81...], [ 1. ..., 0. ..., 0. ...], [ 0. ..., 0.70..., -0.70...]]) 方法2：sklearn.preprocessing.StandardScaler类 123&gt;&gt;&gt; normalizer = preprocessing.Normalizer().fit(X) # fit does nothing &gt;&gt;&gt; normalizer Normalizer(copy=True, norm='l2') 然后使用正则化实例来转换样本向量： 123456&gt;&gt;&gt; normalizer.transform(X) array([[ 0.40..., -0.40..., 0.81...], [ 1. ..., 0. ..., 0. ...], [ 0. ..., 0.70..., -0.70...]]) &gt;&gt;&gt; normalizer.transform([[-1., 1., 0.]]) array([[-0.70..., 0.70..., 0. ...]]) 两种方法都可以，效果是一样的。 五、二值化(Binarization) 特征的二值化主要是为了将数据特征转变成boolean变量。在sklearn中，sklearn.preprocessing.Binarizer函数可以实现这一功能。实例如下： 12345678910&gt;&gt;&gt; X = [[ 1., -1., 2.], ... [ 2., 0., 0.], ... [ 0., 1., -1.]] &gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X) # fit does nothing &gt;&gt;&gt; binarizer Binarizer(copy=True, threshold=0.0) &gt;&gt;&gt; binarizer.transform(X) array([[ 1., 0., 1.], [ 1., 0., 0.], [ 0., 1., 0.]]) Binarizer函数也可以设定一个阈值，结果数据值大于阈值的为1，小于阈值的为0，实例代码如下： 12345&gt;&gt;&gt; binarizer = preprocessing.Binarizer(threshold=1.1) &gt;&gt;&gt; binarizer.transform(X) array([[ 0., 0., 1.], [ 1., 0., 0.], [ 0., 0., 0.]]) 六、缺失值处理 由于不同的原因，许多现实中的数据集都包含有缺失值，要么是空白的，要么使用NaNs或者其它的符号替代。这些数据无法直接使用scikit-learn分类器直接训练，所以需要进行处理。幸运地是，sklearn中的Imputer类提供了一些基本的方法来处理缺失值，如使用均值、中位值或者缺失值所在列中频繁出现的值来替换。 下面是使用均值来处理的实例： 12345678910&gt;&gt;&gt; import numpy as np &gt;&gt;&gt; from sklearn.preprocessing import Imputer &gt;&gt;&gt; imp = Imputer(missing_values='NaN', strategy='mean', axis=0) &gt;&gt;&gt; imp.fit([[1, 2], [np.nan, 3], [7, 6]]) Imputer(axis=0, copy=True, missing_values='NaN', strategy='mean', verbose=0) &gt;&gt;&gt; X = [[np.nan, 2], [6, np.nan], [7, 6]] &gt;&gt;&gt; print(imp.transform(X)) [[ 4. 2. ] [ 6. 3.666...] [ 7. 6. ]] Imputer类同样支持稀疏矩阵： 12345678910&gt;&gt;&gt; import scipy.sparse as sp &gt;&gt;&gt; X = sp.csc_matrix([[1, 2], [0, 3], [7, 6]]) &gt;&gt;&gt; imp = Imputer(missing_values=0, strategy='mean', axis=0) &gt;&gt;&gt; imp.fit(X) Imputer(axis=0, copy=True, missing_values=0, strategy='mean', verbose=0) &gt;&gt;&gt; X_test = sp.csc_matrix([[0, 2], [6, 0], [7, 6]]) &gt;&gt;&gt; print(imp.transform(X_test)) [[ 4. 2. ] [ 6. 3.666...] [ 7. 6. ]] sklearn相关英文版本:Preprocessing data 中文版本:数据预处理 本文提取自：http://blog.csdn.net/dream_angel_z/article/details/49406573","tags":[]},{"title":"windows 10 github page + hexo + pandoc + next 搭建博客","date":"2017-02-13T09:32:25.000Z","path":"2017/02/13/windows 10 github page + hexo + pandoc + next 搭建博客/","text":"之前根据crossin的编程教室一系列教程使用githubpage + hexo + yilia成功搭建了博客，但是知其然不知其所以然，在尝试转变风格为next的时候花了不少功夫，痛定思痛之后决定把这些记录下来，以备将来再次安装使用。 简单的教程很多就不再赘述，直接粘贴当时看的教程。 用 GitHub + Hexo 建立你的第一个博客 部署博客及更新博文 安装自己喜欢的主题 更换markdown渲染引擎 hexo默认只支持最基础的markdown渲染，为了实现现代化的功能（囧），改用pandoc来进行渲染。 首先前往pandoc官网下载并安装pandoc，安装成功后测试pandoc --help命令以确定安装成功。 之后安装pandoc作为hexo的渲染引擎，进入hexo目录后，输入以下命令： npm uninstall hexo-renderer-marked --save npm install hexo-renderer-pandoc --save pandoc和基础markdown语法有细微不同，具体细节可以去官网查阅。 支持LATEX数学公式 hexo目录中，输入以下命令： npm install hexo-math --save hexo math install 并且在网站配置的_config.yml文件中添加： plugins: - hexo-math 最后有一点许多教程都没有提到的，记得去正在使用的主题配置_config.yml中，将MathJex相关支持设定为true。 更换主题为next 依然在hexo目录中，安装next主题 git clone https://github.com/iissnan/hexo-theme-next themes/next 打开站点配置文件_config.yml修改主题为next theme: next 相关建议设置next官网有清楚的描述。 使用Hexo的内建归档categories 作者：碎瞳Artin 链接：https://www.zhihu.com/question/33324071/answer/58775540 来源：知乎 著作权归作者所有，转载请联系作者获得授权。 1.第一步：生成post（文章）时默认生成categories配置项：在根目录下scaffolds/post.md中，添加一行categories:。同理可应用在page.md和photo.md，示例如下： title: {{ title }} date: {{ date }} tags: categories: # 此处为添加内容 --- 2.第二步：在实际写作时，在开头进行categories配置。例如： title: Hello，World!你好，世界！ date: 2014-01-21 23:33:02 tags: 写作 categories: 随笔 # 配置categories 这样在文章发布时，在git中使用hexo g命令，hexo会在根目录/public/categrises下自动生成归档文件夹，如图： image_1b8php9vm1tb71u91170v1kusmrqg.png-26kB 3.第三步：配置博客首页归档展示样式。在主题配置文件themes/_config.yml中添加以下代码（#号后为注释内容）: menu: home: / essay: /categories/随笔 # 博客首页展示文本/访问路径/自定义归档名称 write: /categories/写作 read: /categories/阅读 study: /categories/学习 code: /categories/编程 4.补充说明：如果发现博客首页展示文本为英文，需要改为中文显示，需要修改先博客根目录下的_config.yml文件的language配置，示例如下： # Site title: My Blog subtitle: description: author: language: zh-CN # 修改此处，一般默认为default.yml，原生英文显示 timezone: 然后为实现文章归档名称显示为中文，接着再修改主题配置文件下language/zh-CN.yml即可，示例如下： title: archive: 归档 category: 分类 tag: 标签 menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 essay: 随笔 # 编辑代码时注意语法规范如缩进、空格等 read: 阅读 # Hexo采用yml语法，具体可自行搜索 write: 写作 5.最终展示效果（图中红框作强调用）： image_1b8phsloq155m1dbv9f9cgd6g4t.png-41.6kB 6.点进某一归档分类如“阅读”，博客文章会依照归档配置，排序显示如下： image_1b8pht2l6ifh1neh1k4i3hgsg21a.png-27.1kB **注：目前下载安装的hexo貌似都没有zh-CN.yml，而以zh-Hans代替，第四步修改对应文件即可。 上传博客常用命令 hexo目录下： # 清理缓存 hexo clean # 生成静态文件 hexo generate # 本地预览（在4000端口） hexo s # 提交至网站 hexo deploy 文件前的title各标签视主题而有所不同。","tags":[]},{"title":"数据分析扫盲  --  2.机器学习","date":"2017-01-22T02:39:25.000Z","path":"2017/01/22/数据分析扫盲  --  2.机器学习/","text":"FBIWARNING：本文一切知识点，知识框架均来自于个人对数据分析、数据挖掘、机器学习等方面的理解，推测均出自于本人的臆测，如果对数据分析感兴趣，可以参阅可汗学院的《统计学》、各大学的数据分析和机器学习课程。 基础知识 机器学习定义 机器学习在近30多年已发展为一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、计算复杂性理论等多门学科。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法 – 维基百科 简单从实现上来说，机器学习就是使用机器学习算法来得到目标数据集的最优近似函数的过程。 监督和无监督 监督学习所得到的结果都是已知的，即结果集是可预估的。常见的监督学习算法包括回归分析和统计分类。 无监督学习所得到的结果是未知的，即结果集是不可预估的，常见的无监督学习算法有聚类。 半监督学习继承了监督学习与无监督学习，往往采用少量的数据集使用监督学习得到部分结果，再以大量的无监督学习对结果进行验证和修正。 增强学习通过观察来学习做成如何的动作。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。 数据挖掘 数据挖掘这一词语常与机器学习相混淆，实际上，数据挖掘的总体目标是从一个数据集中提取信息，并将其转换成可理解的结构，以进一步使用。出于发现数据集知识的目的，数据挖掘设计数据管理方面、数据预处理、模型与推断方面考量、兴趣度度量、复杂度的考虑，以及发现结构、可视化及在线更新等后处理。有鉴于此目标，“数据挖掘”实际上和“数据分析”这一名词在同一维度。 机器学习框架 大多数机器学习算法的基本框架都是模型（model/Representation）、代价函数（cost function）、优化算法。 以最简单的线性回归（Linear regression）来举例： 线性回归（模型）常用于有明显线性关系简单模型预测，例如流行病学、金融资产等，其算法的代价函数为最小二乘法（代价函数），即 最终使用梯度下降（优化算法）得到结果。 而在使用Logistic回归（Logistic Regression）算法时，Logistic回归（模型）使用的则是极大似然估计（代价函数），即 最终使用梯度下降（优化算法）得到结果。 最小二乘和极大似然的关系 在不同的情况中使用不同的代价函数，原因是各自的响应变量y服从不同的概率分布。 在线性回归中，前提假设是y服从正态分布，即\\[y\\sim N(\\mu,\\sigma^2)\\]而Logistic回归中的y是服从二项分布的，即\\[y\\sim Bernoulli(\\phi)\\] 因而，在用极大似然估计计算时，所得到的代价函数自然是不一样的。 最小二乘是从函数形式上来看的，极大似然是从概率意义上来看的。事实上，最小二乘可以由高斯噪声假设+极大似然估计推导出来。 所以在较复杂的模型中，一个代价函数可以用不同的优化算法，不同的代价函数也可以用相同的优化算法。 代价函数 代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。 仍以线性回归作为示范，图中X为样本点，垂直蓝线是建模误差，为了得到合适的直线，我们必须令蓝线尽可能短，即建模误差最小。 image_1b72gv22748b11ejve71o60us718.png-20.2kB 为了使代价函数最小，我们绘制套入代价函数结果的三维等高图，即可得到 image_1b72h6eea1vc61qv74rf1t4o1t8l1l.png-69kB 图中最凹点即为代价函数最优情况。（具体函数推导详见coursera机器学习课程2-3）。 全局最优解/局部最优解 接下来，我们以梯度下降作为优化算法来计算代价函数最小值。 我们依然把一个二维数据集加入代价函数，绘制三维等高图，如图所示： image_1b72hdcd5ehjhhk1e68rte1gsp22.png-135.5kB 无论数据初始在什么位置，我们的目标，是进入全局最优点（即全局最低点），也就是机器学习工程师们常说的下山。 想象你正在所示起点，视野范围是有限的，为了尽快下山，你会在前往目之所及选择最低的一点。当你到达之前的最低点，再以此类推继续前往最低点。 如右边的线段所示，很常见的，在下山中不断的寻找有地点，很有可能进入并停留在一个局部最低点，而非全局最优点。这种情况常发生在视距(学习率a，库中命名为alpha)的选择不合适的情况下，降低a的值虽然可以提高进入全局最优点的准确率，也会很大的降低模型的计算速度。 欠拟合和过拟合 以一个分类模型为例： image_1b72i3cnefas1cvrjp9qp2qj22f.png-226.9kB 对一个多项式模型而言，x的次数越多，拟合效果就会越好，但是从操作上，将其控制在一个合适的范围内并不容易，图中第二个模型属于适当的分类，而第一个模型太过松散，称为欠拟合，第三个模型分类过度，称为过拟合，欠拟合和过拟合导致的调参问题一直都是机器学习使用者最大的问题。 在欠拟合中，拟合度不足，我们可以轻松的通过增加x的次数（多项式）来弥补；而在过拟合中，通常有两种处理方法： 1.使用特征工程，来抛弃一些对模型有影响却并没有实际意义的特征。 2.正则化，保留特征，但控制参数的大小。 在实际运用中，一般会同时使用这两种方法。后面会提及这两种方法的具体使用。 算法选择 主要算法 泛指被sklearn等大型库集成的算法。 1.朴素贝叶斯 朴素贝叶斯属于生成式模型（关于生成模型和判别式模型，主要还是在于是否需要求联合分布），比较简单，你只需做一堆计数即可。如果注有条件独立性假设（一个比较严格的条件），朴素贝叶斯分类器的收敛速度将快于判别模型，比如逻辑回归，所以你只需要较少的训练数据即可。即使NB条件独立假设不成立，NB分类器在实践中仍然表现的很出色。它的主要缺点是它不能学习特征间的相互作用，用mRMR中R来讲，就是特征冗余。引用一个比较经典的例子，比如，虽然你喜欢Brad Pitt和Tom Cruise的电影，但是它不能学习出你不喜欢他们在一起演的电影。 优点： 朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。 对小规模的数据表现很好，能个处理多分类任务，适合增量式训练； 对缺失数据不太敏感，算法也比较简单，常用于文本分类。 缺点： 需要计算先验概率； 分类决策存在错误率； 对输入数据的表达形式很敏感。 2.Logistic Regression（逻辑回归） 逻辑回归属于判别式模型，同时伴有很多模型正则化的方法（L0， L1，L2，etc），而且你不必像在用朴素贝叶斯那样担心你的特征是否相关。与决策树、SVM相比，会得到一个不错的概率解释，你甚至可以轻松地利用新数据来更新模型（使用在线梯度下降算法-online gradient descent）。如果需要一个概率架构（比如，简单地调节分类阈值，指明不确定性，或者是要获得置信区间）。 Sigmoid函数：表达式为公式: \\[f(x)=\\frac{1}{1+e^{−x}}\\] 优点： 实现简单，广泛的应用于工业问题上； 分类时计算量非常小，速度很快，存储资源低； 便利的观测样本概率分数； 对逻辑回归而言，多重共线性并不是问题，它可以结合L2正则化来解决该问题； 缺点： 当特征空间很大时，逻辑回归的性能不是很好； 容易欠拟合，一般准确度不太高 不能很好地处理大量多类特征或变量； 只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分； 对于非线性特征，需要进行转换； 3.线性回归 线性回归是用于回归的，它不像Logistic回归那样用于分类，其基本思想是用梯度下降法对最小二乘法形式的误差函数进行优化，当然也可以用normal equation直接求得参数的解，结果为： \\[\\hat{w}=(X^{T}X)^{-1}X^Ty\\] 而在LWLR（局部加权线性回归）中，参数的计算表达式为: \\[\\hat{w}=(X^{T}WX)^{-1}X^TWy\\] 由此可见LWLR与LR不同，LWLR是一个非参数模型，因为每次进行回归计算都要遍历训练样本至少一次。 优点： + 实现简单，计算简单； 缺点： + 不能拟合非线性数据. 4.最近邻算法——KNN KNN即最近邻算法，其主要过程为： 计算训练样本和测试样本中每个样本点的距离（常见的距离度量有欧式距离，马氏距离等）； 对上面所有的距离值进行排序(升序)； 选前k个最小距离的样本； 根据这k个样本的标签进行投票，得到最后的分类类别； 如何选择一个最佳的K值，这取决于数据。一般情况下，在分类时较大的K值能够减小噪声的影响，但会使类别之间的界限变得模糊。一个较好的K值可通过各种启发式技术来获取，比如，交叉验证。另外噪声和非相关性特征向量的存在会使K近邻算法的准确性减小。近邻算法具有较强的一致性结果，随着数据趋于无限，算法保证错误率不会超过贝叶斯算法错误率的两倍。对于一些好的K值，K近邻保证错误率不会超过贝叶斯理论误差率。 优点： 理论成熟，思想简单，既可以用来做分类也可以用来做回归； 可用于非线性分类； 训练时间复杂度为O(n)； 对数据没有假设，准确度高，对outlier不敏感； 缺点: 计算量大（体现在距离计算上）； 样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）效果差； 需要大量内存； 5.决策树 决策树的一大优势就是易于解释。它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别A在某个特征维度x的末端，类别B在中间，然后类别A又出现在特征维度x前端的情况）。它的缺点之一就是不支持在线学习，于是在新样本到来后，决策树需要全部重建。另一个缺点就是容易出现过拟合，但这也就是诸如随机森林RF（或提升树boosted tree）之类的集成方法的切入点。 决策树中很重要的一点就是选择一个属性进行分枝，因此要注意一下信息增益的计算公式，并深入理解它。 信息熵的计算公式如下: \\[H=-\\sum^{n}_{i=1}p(x_i)log_2p(x_i)\\] 其中的n代表有n个分类类别（比如假设是二类问题，那么n=2）。分别计算这2类样本在总样本中出现的概率p1和p2，这样就可以计算出未选中属性分枝前的信息熵。 现在选中一个属性x用来进行分枝，此时分枝规则是：如果x=v的话，将样本分到树的一个分支；如果不相等则进入另一个分支。很显然，分支中的样本很有可能包括2个类别，分别计算这2个分支的熵H1和H2,计算出分枝后的总信息熵H’ =p1 H1+p2 H2,则此时的信息增益ΔH = H - H’。以信息增益为原则，把所有的属性都测试一边，选择一个使增益最大的属性作为本次分枝属性。 优点： 计算简单，易于理解，可解释性强； 比较适合处理有缺失属性的样本； 能够处理不相关的特征； 在相对短的时间内能够对大型数据源做出可行且效果良好的结果。 缺点： 容易发生过拟合（随机森林可以很大程度上减少过拟合）； 忽略了数据之间的相关性； 对于那些各类别样本数量不一致的数据，在决策树当中,信息增益的结果偏向于那些具有更多数值的特征（只+ 要是使用了信息增益，都有这个缺点，如RF）。 5.1 Adaboosting Adaboost是一种加和模型，每个模型都是基于上一次模型的错误率来建立的，过分关注分错的样本，而对正确分类的样本减少关注度，逐次迭代之后，可以得到一个相对较好的模型。该算法是一种典型的boosting算法，其加和理论的优势可以使用Hoeffding不等式得以解释。 优点： Adaboost是一种有很高精度的分类器。 可以使用各种方法构建子分类器，Adaboost算法提供的是框架。 当使用简单分类器时，计算出的结果是可以理解的，并且弱分类器的构造极其简单。 简单，不用做特征筛选。 不易发生过拟合。 缺点： 对离散值比较敏感 6.SVM支持向量机 支持向量机，一个经久不衰的算法，高准确率，为避免过拟合提供了很好的理论保证，而且就算数据在原特征空间线性不可分，只要给个合适的核函数，它就能运行得很好。在动辄超高维的文本分类问题中特别受欢迎。可惜内存消耗大，难以解释，运行和调参也有些烦人，而随机森林却刚好避开了这些缺点，比较实用。 优点： 可以解决高维问题，即大型特征空间； 能够处理非线性特征的相互作用； 无需依赖整个数据； 可以提高泛化能力； 缺点： 当观测样本很多时，效率并不是很高； 对非线性问题没有通用解决方案，有时候很难找到一个合适的核函数； 对缺失数据敏感； 对于核的选择也是有技巧的（libsvm中自带了四种核函数：线性核、多项式核、RBF以及sigmoid核）： 第一，如果样本数量小于特征数，那么就没必要选择非线性核，简单的使用线性核就可以了； 第二，如果样本数量大于特征数目，这时可以使用非线性核，将样本映射到更高维度，一般可以得到更好的结果； 第三，如果样本数目和特征数目相等，该情况可以使用非线性核，原理和第二种一样。 对于第一种情况，也可以先对数据进行降维，然后使用非线性核，这也是一种方法。 7. 人工神经网络的优缺点 （人工神经网络目前主要是深度学习的范畴） 优点： 分类的准确度高； 并行分布处理能力强,分布存储及学习能力强， 对噪声神经有较强的鲁棒性和容错能力，能充分逼近复杂的非线性关系； 具备联想记忆的功能。 缺点： 神经网络需要大量的参数，如网络拓扑结构、权值和阈值的初始值； 不能观察之间的学习过程，输出结果难以解释，会影响到结果的可信度和可接受程度； 学习时间过长,甚至可能达不到学习的目的。 8、K-Means聚类 优点： 算法简单，容易实现 ； 对处理大数据集，该算法是相对可伸缩的和高效率的，因为它的复杂度大约是O(nkt)，其中n是所有对象的数目，k是簇的数目,t是迭代的次数。通常k&lt;&lt;n。这个算法通常局部收敛。 算法尝试找出使平方误差函数值最小的k个划分。当簇是密集的、球状或团状的，且簇与簇之间区别明显时，聚类效果较好。 缺点： 对数据类型要求较高，适合数值型数据； 可能收敛到局部最小值，在大规模数据上收敛较慢 K值比较难以选取； 对初值的簇心值敏感，对于不同的初始值，可能会导致不同的聚类结果； 不适合于发现非凸面形状的簇，或者大小差别很大的簇。 对于”噪声”和孤立点数据敏感，少量的该类数据能够对平均值产生极大影响。 仿生/模拟算法 通过对自然过程的模拟，对原有算法进行优化，也叫启发式算法（人工神经网络和深度学习也在其中）。 ### 9.蚁群算法 又称蚂蚁算法，是一种用来在图中寻找优化路径的机率型算法。其灵感来源于蚂蚁在寻找食物过程中发现路径的行为。蚁群算法是一种模拟进化算法，初步的研究表明该算法具有许多优良的性质.针对PID控制器参数优化设计问题，将蚁群算法设计的结果与遗传算法设计的结果进行了比较，数值仿真结果表明，蚁群算法具有一种新的模拟进化优化方法的有效性和应用价值。 10.粒子群算法(PSO) 又称微粒群算法，该算法使用如下心理学假设：在寻求一致的认知过程中，个体往往记住自身的信念，并同时考虑同事们的信念。当其察觉同事的信念较好的时候，将进行适应性地调整。 流程如下： 初始化一群微粒（群体规模为m），包括随机的位置和速度； 评价每个微粒的适应度； 对每个微粒，将它的适应值和它经历过的最好位置pbest的作比较，如果较好，则将其作为当前的最好位置pbest； 对每个微粒，将它的适应值和全局所经历最好位置gbest的作比较，如果较好，则重新设置gbest的索引号； 根据方程（1）变化微粒的速度和位置； 如未达到结束条件（通常为足够好的适应值或达到一个预设最大代数Gmax），回到2）。 11.模拟退火算法 模拟退火算法的原理同金属退火类似：将搜寻空间内每一点想像成空气内的分子；分子的能量，就是它本身的动能；而搜寻空间内的每一点，也像空气分子一样带有“能量”，以表示该点对命题的合适程度。算法先以搜寻空间内一个任意点作起始：每一步先选择一个“邻居”，然后再计算从现有位置到达“邻居”的概率。 在一个模型中，模拟退火算法起到的作用是跳崖，防止进入局部最优解。 12.禁忌搜索算法 类似于模拟退火算法的目标，具体方式为其先创立一个初始化的方案，基于此，算法“移动”到一相邻的方案。经过许多连续的移动过程，以提高解的质量。 其它优化算法 13.TF-IDF算法 TF-IDF是一种文本统计方法，字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。常见于将文本转换为数值以相互比较和计算。 算法过程： 数据处理及应用 数据缩放 在特征工程中，除了算法使用代价函数，还可以将不同特征的量纲控制在一定范围内。 在梯度下降的使用中，面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯 度下降算法更快地收敛。面对不同量纲的数据，解决的方法是尝试将所有特征的尺度都尽量缩放到-1 到 1 之间。以解决特征量纲的干扰。 算法表现为： \\[ x_n = \\frac{x_n-\\mu}{s_n} \\] 缺失值/离散值/极大极小值的处理 数据集难免存在缺失数据和录入错误的极端值数据，极大极小值也会影响模型，因此有不同的处理方式。 缺失值：判断数值的缺失是否合理。如果缺失不合理，考虑在数据足够大的条件下删除此数据；如果缺失合理或数据大小不适合删除此条数据，根据陈天奇大牛的建议，可以将此数据设为-999。 离散值：判断数值的离散是否合理，如果合理则保存此数据；如果不合理，则查看是否可以判断不合理原因给予修正；如无法修正，可以考虑作同缺失值的处理。 极大极小值：对不支持的模型，将其作为缺失值处理。 降维 数据集的某些无意义特征的存在不但降低模型计算速度，还会形成噪音影响模型。因此通过数据降维来提升模型质量。降维的计算比较复杂，在不同的模型中应用方式也各有不同，好在大型的机器学习库都提供了相应的算法，不多赘述，详见解析。 稀疏矩阵 稀疏矩阵是指将离散化的特征拆开，形成新的多个特征的一种手段，新生成的特征中只包含True（1）和False（0），且大部分元素都为False(0)的矩阵。实际上，连续性数据也可以通过分组达到此目的。 稀疏矩阵的目的主要是通过其自身的稀疏特性，通过压缩可以大大节省稀疏矩阵的内存代价，从而加快模型的运算速度，更重要的是当数据过大时，通过稀疏矩阵，标准化的算法将之前不可操作的数据变为可操作数据。 sklearn虽然集成了稀疏矩阵函数，但其效果并不优秀。在python语言中，可以依赖pandas的get_dummies函数将数据快速化为稀疏举证。具体信息详见：机器学习中的范数规则化之（一）L0、L1与L2范数。 调参 调参往往是模型碰到的最后敌人，当准备工作处理完毕后，不同的参数对结果会造成很大的不同，因此调参技巧是机器学习工程师必须要掌握的内容。直接贴一篇大神的文章，剩下的坑以后再补…","tags":[]},{"title":"数据分析扫盲  --  1.传统数据分析","date":"2017-01-19T06:21:08.000Z","path":"2017/01/19/数据分析扫盲  --  1.传统数据分析/","text":"FBIWARNING：本文一切知识点，知识框架均来自于个人对数据分析、数据挖掘、机器学习等方面的理解，推测均出自于本人的臆测，如果对数据分析感兴趣，可以参阅可汗学院的《统计学》、各大学的数据分析和机器学习课程。 数据分析定义 数据分析是指用适当的统计方法对收集来的大量第一手资料和第二手资料进行分析，以求最大化地开发数据资料的功能，发挥数据的作用。 “上帝函数” 吴恩达（机器学习领域四大牛之一）在coursera的《机器学习》中提到，对所有的数据总体而言，有且必然有一条能够完美解释此样本的函数，称为“上帝函数”。但是上帝函数无法通过计算得到（所有的统计，都是对样本的统计，而不是对数据总体的统计；另外对总体而言，即使数据是离散的，函数在复杂样本的数学意义上还是连续的），只能无限的逼近它。 数据分析方向 数据分析的数学基础在20世纪早期就已确立，直到计算机出现才使得数据分析成为可能，在计算机性能不高时，以计算机协助人进行统计学分析以获得数据判断，这种数据分析方法被称为数据分析或传统数据分析。 随着计算机性能增长以及最小二乘法和梯度下降优化思想得以被大规模应用到机器中，数据分析师得以从有价值的信息中更快速、更准确的得到更接近于“上帝函数”的数学结果。针对不同类型的数据集，也有不同的经典模型套用以快速求得最优结果。此时使用者已经不再关注基础统计学指标，而是转向了挖掘数据知识、关系探索等方向，这种数据分析方法被称为数据挖掘或机器学习。 传统数据分析本质 在各种场景下（限定条件/逻辑），应用统计学（工具）对数据分析后的结果进行解释（逻辑），得到更接近真实情况的客观数据帮助决策的一种判断方式。 数据集的描述和定义 传统数据分析工具 在大多数需要统计的商业环境中，大型工具基本只有两种：SPSS和SAS。SPSS属于傻瓜相机，利用定制好的选项和图形界面在略懂统计知识的情况下即可作出符合传统数据分析的结论；如果有更深层的需求，例如银行、金融等环境，SAS能通过SAS语言用编程的形式制作所需的数据模型，从而得到更高定制化、更精确、性能更高的结果；此外，还有统计师使用MATLAB编程来达到所需目标。当然，以上三款软件所需都是不菲。因此在python和机器学习走强的今天，传统的统计工具只能保全大型金融机构这样的大客户，还是走向了衰败。R、oracle等语言也跟着大放异彩。 描述性统计分析 描述性统计分析是传统数据分析的基础，在此过程中需要求出数据分析的基础指标，包括： 平均值：常用的统计指标，受极端值影响。 中位数：数据以升序或降序排列后，处于最中间的数。如果数据呈现二向分布，中位数的表达会受极大的影响，且不能表现数据中极端值的影响。 众数：出现最多的数，缺点同上。 方差/标准差：反应样本个体之间的离散程度，统计学重要指标之一，有较多的应用。 上/下四分位数：数据以升序或降序排列后，25%位置与75%位置的值，常用于箱线图等对数据的图像展示。延伸有四分位数间距 偏度：数据倾向于左边（左偏）或右边（右偏），对股票、公司财务健康等数据有较为重要的意义。 变异系数：数据标准差与平均数的比，反应离散程度，常用于对比不同量纲的数据中消除离散程度。 二项分布 二项分布即重复n次独立的伯努利试验。最简单的二项分布就是掷硬币游戏。虽然二项分布的概率是人类的常识，但二项分布的数学推导并不简单。此外，统计学中许多重要分布例如正态分布、伯努利分布、泊松分布等等都是以二项分布作为基础推导而出的。因此在统计学中，二项分布具有极其重要的意义。 正态分布 正态分布，又称钟形曲线。该分布展示了数据频数与分布域的关系，许多统计定理都是以正态分布为基础，该分布是统计学中的核心。详细描述请参考百度百科。 正态分布之所以有巨大的研究价值，是因为大多数干预或未经干预的数据都呈正态分布状，从自然界各个数值的分布，到人类的行为，产品的偏差，基本都符合正态分布模式（其实是因为中心极限定理，呈现为正态分布）。掌握正态分布理论意味着在不清楚总体分布情况时，可以根据该数据的属性做其是否是正态分布的推测，可以轻易获得某情况较为接近真实存在的概率。 正态分布也是统计学思维一种表现形式，“如果一直猴子坐在电脑前无限的敲打键盘，那么它终有一天能敲出莎士比亚全集”就是其中之一：从正态分布来看，我们无法绝对否定一件事情的发生概率，只能说“很有可能”会产生这样的结果，这也是有很多讽刺统计学家笑话的原因。 ## 泊松分布 泊松分布适合于描述单位时间内随机事件发生的次数。泊松分布在管理科学、运筹学以及自然科学的某些问题中都占有重要的地位。详情见百度百科。 泊松分布可以在掌握部分样本的情况下，推测其值落在各个区间的概率。 ## 经验法则和切比雪夫不等式 当一组数据对称分布时（经验法则）： 约有68%的数据在平均数1个标准差以内。 约有95%的数据在平均数 2个标准差以内。切比雪夫不等式认为在75%个 约有99%的数据在平均数 3个标准差以内。 3个标准差以外的数据，在统计学上称为“离群点”。 当一组数据非对称分布时（切比雪夫不等式）： 约有75%的数据落在平均数 2个标准差以内。 约有89%的数据落在平均数 3个标准差以内。 约有94%的数据落在平均数 4个标准差以内。 实际使用上，切比雪夫不等式的估算效果并不好，只有当经验法则无法使用时（无标准界定，常用于偏度&gt;0.4）才会使用切比雪夫不等式。 大数定理和中心极限定理 大数定理和中心极限定理是统计学中最重要的两条定理，我认为因为这两条定理存在，才能切实的奠定统计学的价值，并且是统计学思维的根源 大数定理：又称大数法则，论证了在大量重复试验的过程中，样本量越多，样本平均值越接近于总体平均值。上文提到的切比雪夫不等式，是大数定理的一种特殊分布。详见维基百科。 中心极限定理：中心极限定理论证了在样本数较大时（通常定义为n&gt;30），样本均值近似正态分布。该定理在大数定理的基础上，给出了收敛的极限分布和渐近方差，更深入的研究了正态分布，是数理统计学和误差分析理论的研究基础。详见维基百科。 概率 概率基础：从三个问题说开去 赌徒谬论 超生游击队员老王已经连生4个闺女了，但老王实在太想要一个男娃，虽然家产都快被村里计生委的人给罚光，但还是要生，他想，都连生4个了，下个肯定是个带把的。 那么问题是，下一个小孩是男孩的概率？ 三门问题 假设你参加了一个电视节目，过关斩将来到了最后一关，此时你看见三扇关闭了的门，其中一扇的后面是一辆法拉利，另外两扇门后是山羊，当你选中了法拉利时，你就可以将其带走；如果选中了山羊，就会空手而归。支持人知道所有门后是什么。 你选定2号门后，主持人为了增加悬念，打开了3号门，门后是一只山羊，此时主持人询问你你是否要更换你的选择。那么问题是，是否应该更换选择？ ### 辛普森悖论 你是一位校长，假设有一天漂亮的秘书跑过来对你说：“校长，不好了，有很多男生在校门口抗议，他们说今年研究所女生录取率是男生的两倍，指责我们学校有性别歧视！” 这时你也很生气，说：“我不是特别交代，今年要尽量提升男生录取率以免落人口实吗？” 秘书赶紧回答说：“确实有交代下去，招生办说今年的男生确实比女生多，可是报告上显示男生所有学科录取率都比女生低了很多。” 那么问题是：有可能在男生所有学科录取率均比女生低的情况下，总性别比例还保持不变吗？ 辛普森悖论.jpg-8.6kB 概率论中需要注意的基础问题 以中国人平均数学水平来说，基础概率的计算基本不是问题，只需要注意一些概率计算的基本假设： 赌徒谬论：当事件与事件之间是相互独立的，不能联合计算概率，百度百科 三门问题：概率是随条件的改变而变化的，概率存在于被给予的条件下，概率不能寄托在实际的物体上，百度百科 辛普森悖论：在某个条件下的两组数据，分别讨论时都会满足某种性质，可是一旦合并考虑，却可能导致相反的结论，百度百科。 组合法则 组合法则是迅速计算在N内取n个有多少种方法的计算公式，体现为： \\[\\left( \\begin{matrix} N \\\\ n \\\\ \\end{matrix} \\right) = \\frac{N!}{(N-n)!} \\] 例如从4个项目中挑选2个来进行投资，则有: \\[\\left( \\begin{matrix} N \\\\ \\end{matrix} \\right) = \\frac{4!}{2! 2!} = \\frac{4\\times3\\times2\\times1}{(2\\times1)(2\\times1)} = 6\\] 贝叶斯定理 通常，事件A在事件B（发生）的条件下的概率，与事件B在事件A（发生）的条件下的概率是不一样的，然而，这两者是有确定的关系的；贝叶斯定理通过的是A、B事件转换而得到目标概率，贝叶斯公式的一个用途在于通过已知的三个概率函数推出第四个。 $ P(A|B) = $ 下面通过一道题来理解贝叶斯定理。 对残疾人来说，电动轮椅很难驾驭。假设在房间的某一位置，轮椅使用者可以选择D（穿过房门），S（直行），T（停在桌旁），使用者意愿的概率分别是P(D)=0.5，P(S)=0.2，P(T)=0.3；当轮椅使用者将控制杆转向前时（记为J），则有P(J|D)=0.3，P(J|S)=0.4，P(J|T)=0.05。如果此时使用者将操作杆向前，各种情况的概率各是多少？ 其中P(D|J)的解为： P(D|J) = P(J|D) * P(D) / P(J) P(D|J) = P(J|D) * P(D) / (P(D) * P(J|D) + P(S) * P(J|S) + P(T) * P(T|J)) P(D|J) = 0.3 * 0.5 / 0.245 P(D|J) = 0.612 置信区间 置信区间：置信区间是对分布（尤其是正态分布）的一种深入研究。通过对样本的计算，得到对某个总体参数的区间估计，展现为总体参数的真实值有多少概率落在所计算的区间里（目前国内的统计不接受概率的说法，认为此操作不应属于概率的范畴）。置信水平越高，置信区间就会越宽；在置信水平不变的情况下，样本数量越多，置信区间越窄，且置信区间的需求样本量可以被计算出来。 一般来说，置信区间一般会选择95%。 假设检验 “反证法是统计学者最强大的武器！” – 想不起来谁说的了 假设检验是一种用反证法证明对立条件（原假设/H0），从而判断目前条件（备择假设/Ha）是否正确的证明方式。常见名词如下： P值：观测的显著性水平，通过不同方式计算后，如果P值落在原假设的拒绝域，则拒绝原假设。 接受域：原假设的区间。 拒绝域：拒绝原假设的区间。 I类错误：原假设为真时，拒绝原假设。 II类错误：备择假设为真时，接受原假设。 单样本下的计算方法 在单样本下，置信区间和假设检验主要使用z统计和学生t统计（也称t检验）。 z统计和学生t统计是两种应用正态分布，求置信区间的计算方式。z统计应用于大样本的计算，因为中心极限定理的存在，z统计不要求该样本分布属于正态分布（因为会整理成近似正态分布）；学生t统计量主要应用于小样本的计算，要求总体分布必须近似正态分布，同时所取得的置信区间在同置信水平下也要比z统计得到的结果更宽。 两样本下的计算方法 两样本下，在统一量纲，消除样本均值差后，就可以使用常用统计方法来检验相关性。除了z统计和t统计外，还可使用卡方检验、F检验等。 在SPSS/SAS甚至excel等软件中，以上基础的检验方法都被大规模的修正/革新，所以基础的公式基本已经不会被使用了。 ## 更多样本，更多方法 在更多样本中，不同计算方法的差距会越来越大，传统数据分析更着眼于方差分析等检测样本相关性，简单线性回归线等，因此，样本的抽样和配对方法对模型造成的影响也会增加。除了以上介绍的统计方法，还有F统计，U检定等大项，每种大项下都有许多经过统计学家门修正的方法，在此不多赘述。 抽样组织形式 简单随机抽样：任何样本数为n的抽样几率都是相等的。 等距抽样/系统抽样：以总体N除以样本数n得到整数K，随机选择一个元素为R，以R开始，每隔K个的元素作为样本。 集群抽样：将总数分割成小的集群，再用简单随机抽样抽取小的集群，将集群作为样本。 二段随机抽样：先用集群抽样出集群，再对集群进行集群抽样。 传统统计分析总结 在以上知识的基础上，统计学家们更热衷修正原有的经典检验方法，以逻辑为推进从数学上增强各种推断检验标准，但也人类思维的局限性，模型的解释性强必然造成预测能力的削弱，这也是机器学习专家和统计学家重要的不同之处。统计学家集中了现代数学的精华，从数理上证明了SVM，boosting等理论基础，但是在实践和探索未知知识的路上，统计学家并未作出卓越的贡献。","tags":[]},{"title":"瞎聊聊怎么造个人工智能","date":"2017-01-05T05:13:19.000Z","path":"2017/01/05/瞎聊聊怎么造个人工智能/","text":"0 给黑猩猩一把枪，在教会他开枪之后，他会无聊的把枪丢掉，即使知道这能帮助他杀死自己的敌人。 人类则不一样，人类在大自然中是一个奇怪的、乐于争斗的物种。在电影里，为了营造冲突，人类不停的给自己制造着反派。随着人类认知的发展，我们得不停的为反派升级来试着在电影里毁灭人类，从鬼神、人类本身、外星人到新一代的人工智能。 从《太空漫游》开始，人类就不断在畅想人工智能，《太空漫游》还不错，起码AI不是坏人，接下去就慢慢不太对劲了，《终结者》、《机器公敌》、《鹰眼》，反正一个个人工智能都想毁灭人类。 OK，那我们作为程序员的问题是，怎样才能造一款能毁灭人类的人工智能？ 一个AI，想要迅速成长，一定不能受人力的限；不受人力的限制，一定要实现自学习；要应用自学习的成果，一定要实现代码的自我迭代，让机器自己给自己写代码。 就像《环形使者》一样，AI造出自己的下一版AI，如果AI可用，将会杀死前一个自己，不停的尝试自我毁灭的方式。 1 刚开始思考的时候就陷入一个错误的方向：AI要实现自学习，第一要实现代码识别，分析代码的意图，了解代码的意义，从而学会为了实现这个意义的写作方式；第二要实现提出需求，AI得知道“我需要一个列表来放置元素”才能制造一个列表。以此不断分解业务，由无数小的业务组成大的业务，最终实现自学习。 直到我看到了鸭子预测 &gt; 如果一只鸭子看起来像鸭子，游泳像鸭子，叫声像鸭子，那么它就是只鸭子。 智能生物对明显具有外部特征的定义，会选择只看表象来判断，而不是把它解剖了来确认；同理，机器只要了解通过代码中的数值转换，明白其最终达到了业务目标，那这就是代码的意义，除了结果之外，代码内容只是实现的“工具”而已，AI只需记住这么转换是可行的，下次就照着做准没错–如果错了，就去找下一段代码。 1956年的夏天，40岁的香农和28岁的麦卡锡、明斯基、37岁的罗切斯特及其他六位大神一起举办了朴茨茅斯会议，尝试解决自然语言处理的问题。世界上最聪明的10个人头脑风暴了一个月，最后得到的结论还有没有当代一个机器学习PHD在读脑子里的东西多–他们一度陷入了机器“翻译”是基于“理解”的错误上，实际上，华生实验室90年代的成果表明，机器不需要了解词语的意义，只需要按照大数据的理念找到这种情况的其他做法就行，这一成果一夜之间让机器翻译的准确率从70%提升到了90%。 其实人类对“原理”的理解，也只是用自己的所见去解释而已，我们不知道我们是不是活在《黑客帝国》里，我们不知道是不是三体人的质子正在干扰我们，我们不需要知道这么多。 AI也不需要知道。","tags":[]}]