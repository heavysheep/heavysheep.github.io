<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="天生极客">
<meta property="og:type" content="website">
<meta property="og:title" content="王子子的成长之路">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="王子子的成长之路">
<meta property="og:description" content="天生极客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王子子的成长之路">
<meta name="twitter:description" content="天生极客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 王子子的成长之路 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">王子子的成长之路</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">王子子</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-course">
          <a href="/categories/历程" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-blind"></i> <br />
            
            历程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-study">
          <a href="/categories/学习" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-plug"></i> <br />
            
            学习
          </a>
        </li>
      
        
        <li class="menu-item menu-item-essay">
          <a href="/categories/随笔" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-optin-monster"></i> <br />
            
            随笔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/不忘初心，也不在乎什么始终/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="王子子">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/large/646083e8jw1e4k8rg9xhdj20ai0am3z6.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="王子子的成长之路">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="王子子的成长之路" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/26/不忘初心，也不在乎什么始终/" itemprop="url">
                  不忘初心，也不在乎什么始终
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-26T21:43:12+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随便/" itemprop="url" rel="index">
                    <span itemprop="name">随便</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直有不要把兴趣和事业混为一谈的说法，我仔细看过，都很有道理。</p>
<p>想象过一些人痛心疾首的望着我说，“你在这有天分，你不做是在浪费你的才华！”这时我就呵呵一笑，“我的才华还有很多，不差浪费这一点”。</p>
<p>好在我的兴趣不需要什么卓越的智商和天分，就是门手艺而已。而手艺是需要磨练的，没时间磨练还搞什么手艺。</p>
<p>好比你爱上一个姑娘，要是两情相悦最好。可要是单恋一枝花，你也没什么办法。</p>
<p>离开舒适区，回到起点，做喜欢的事情，要是摔到头破血流–也没什么办法不是。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/18/机器学习实战读书笔记 -- 朴素贝叶斯/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="王子子">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/large/646083e8jw1e4k8rg9xhdj20ai0am3z6.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="王子子的成长之路">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="王子子的成长之路" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/18/机器学习实战读书笔记 -- 朴素贝叶斯/" itemprop="url">
                  机器学习实战读书笔记 -- 朴素贝叶斯
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-18T14:04:06+08:00">
                2017-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近太忙，实在没时间充电了，翻出一篇一年前的学习笔记先顶一下，虽然当今机器学习框架已经封装的非常好了，但是了解何时使用和算法里发生了什么也是很重要的。</p>
<h2 id="简介">简介</h2>
<p>用python的文本处理能力将文档切分成词向量，对文档进行分类和过滤，最终将结果转换成人可以理解的信息。<br>
优点：在数据较少的情况下仍然有效，可以处理多类别问题。<br>
缺点：对于输入数据的准备方式较为敏感。<br>
使用数据类型：标称型数据。</p>
<h2 id="流程">流程</h2>
<p>朴素贝叶斯的一般流程：<br>
1.收集数据：可以使用任何方法。<br>
2.准备数据：需要数值型或者布尔型数据。<br>
3.分析数据：有大量特征时，绘制特征作用不大，此时使用直方图效果更好。<br>
4.训练算法：计算不同的独立特征的条件概率。<br>
5.测试算法：计算错误率。<br>
6.使用算法：一个常见的朴素贝叶斯应用是文档分类。可以在任意的分类场景中使用朴素贝叶斯分类器。</p>
<h2 id="使用情况分类">使用情况分类</h2>
<p>决策树和朴素贝叶斯的使用情况分类：<br>
决策树适合标准的离散化数据，并且对数值型数据的处理难以处理。<br>
朴素贝叶斯的要求相对较低。</p>
<h2 id="示例代码">示例代码</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*- encoding:utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></div><div class="line">    postingList=[[<span class="string">'my'</span>,<span class="string">'dog'</span>,<span class="string">'has'</span>,<span class="string">'flea'</span>,<span class="string">'problems'</span>,<span class="string">'help'</span>,<span class="string">'please'</span>],</div><div class="line">                 [<span class="string">'maybe'</span>,<span class="string">'not'</span>,<span class="string">'take'</span>,<span class="string">'him'</span>,<span class="string">'to'</span>,<span class="string">'dog'</span>,<span class="string">'park'</span>,<span class="string">'stupid'</span>,],</div><div class="line">                 [<span class="string">'my'</span>,<span class="string">'dalmation'</span>,<span class="string">'is'</span>,<span class="string">'so'</span>,<span class="string">'cute'</span>,<span class="string">'I'</span>,<span class="string">'love'</span>,<span class="string">'him'</span>],</div><div class="line">                 [<span class="string">'stop'</span>,<span class="string">'posting'</span>,<span class="string">'stupid'</span>,<span class="string">'worthless'</span>,<span class="string">'garbage'</span>],</div><div class="line">                 [<span class="string">'mr'</span>,<span class="string">'licks'</span>,<span class="string">'ate'</span>,<span class="string">'my'</span>,<span class="string">'steak'</span>,<span class="string">'how'</span>,<span class="string">'to'</span>,<span class="string">'stop'</span>,<span class="string">'him'</span>],</div><div class="line">                 [<span class="string">'quit'</span>,<span class="string">'buying'</span>,<span class="string">'worthless'</span>,<span class="string">'dog'</span>,<span class="string">'food'</span>,<span class="string">'stupid'</span>]]</div><div class="line">    <span class="comment">#1 代表侮辱性文字，0代表正常言论</span></div><div class="line">    classVec=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]  </div><div class="line">    <span class="keyword">return</span> postingList,classVec</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></div><div class="line"><span class="comment"># 取唯一值</span></div><div class="line">    vocabSet=set([])</div><div class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</div><div class="line">        vocabSet=vocabSet|set(document)</div><div class="line">    <span class="keyword">return</span> list(vocabSet)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span><span class="params">(vocabList,inputSet)</span>:</span></div><div class="line">    <span class="comment"># 参数1唯一值  当前列表参数2原值，出现在当前词组出现在总词库中的索引</span></div><div class="line">    returnVec=[<span class="number">0</span>]*len(vocabList)</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</div><div class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</div><div class="line">            returnVec[vocabList.index(word)]=<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">"the word %s is not in my Vocablary!"</span>%word</div><div class="line">    <span class="keyword">return</span> returnVec</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix,trainCategory)</span>:</span>  </div><div class="line">    <span class="comment">#只针对二分类问题</span></div><div class="line">    numTrainDocs=len(trainMatrix)  <span class="comment"># 统计有几个训练用词组文档</span></div><div class="line">    numWords=len(trainMatrix[<span class="number">0</span>])  <span class="comment"># 词库数量</span></div><div class="line">    pAbusive=sum(trainCategory)/float(numTrainDocs)  <span class="comment"># 侮辱性词组数量和词组数量的比值</span></div><div class="line">    p0Num=ones(numWords);p1Num=ones(numWords)  <span class="comment">#p0Num,p1Num等于总词库数量个1</span></div><div class="line">    p0Denom=<span class="number">2.0</span>;p1Denom=<span class="number">2.0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):  <span class="comment"># 以i遍历每个词组</span></div><div class="line">        <span class="keyword">if</span> trainCategory[i]==<span class="number">1</span>:  <span class="comment"># 如果是侮辱性词组</span></div><div class="line">            p1Num+=trainMatrix[i]  <span class="comment"># 每个词在总词库副本中的计数+1</span></div><div class="line">            p1Denom+=sum(trainMatrix[i])  <span class="comment">#侮辱性词组中单词的总数</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            p0Num+=trainMatrix[i]  <span class="comment"># 每个词在总词库中的计数+1</span></div><div class="line">            p0Denom+=sum(trainMatrix[i])  <span class="comment"># 非侮辱性词组中单词的总数</span></div><div class="line">    p1Vect=log(p1Num/p1Denom)  <span class="comment"># 侮辱性词在词库中的占比,避免下溢出，采取自然底数</span></div><div class="line">    p0Vect=log(p0Num/p0Denom)  <span class="comment"># 非侮辱词在词库中的占比</span></div><div class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span><span class="params">(vec2Classify,p0Vec,p1Vec,pClass1)</span>:</span></div><div class="line">    p1=sum(vec2Classify*p1Vec)+log(pClass1)  <span class="comment"># 出现词组的位置与总字库内词组向量相乘，加自然底数中侮辱性词库在词库中的占比</span></div><div class="line">    p0=sum(vec2Classify*p0Vec)+log(<span class="number">1.0</span>-pClass1)</div><div class="line">    <span class="comment"># 权重越大，说明可能性越高</span></div><div class="line">    <span class="keyword">if</span> p1&gt;p0:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></div><div class="line">    listOPosts,listClasses=loadDataSet()  <span class="comment"># 原文档和词组是否为侮辱性词汇的定义</span></div><div class="line">    myVocabList=createVocabList(listOPosts)  <span class="comment"># 总词库，每个词都是唯一的</span></div><div class="line">    trainMat=[]</div><div class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:  <span class="comment"># 形成一个二维数组，内有每个在总词库，文档单词在库中的索引</span></div><div class="line">        trainMat.append(setOfWords2Vec(myVocabList,postinDoc))</div><div class="line">    p0V,p1V,pAb=trainNB0(array(trainMat),array(listClasses))  <span class="comment"># 返回每个词组的侮辱性语言概率，非侮辱性语言概率，侮辱性语言再词库中所占比</span></div><div class="line">    testEntry=[<span class="string">'love'</span>,<span class="string">'my'</span>,<span class="string">'dalmation'</span>]<span class="comment">#测试词汇</span></div><div class="line">    thisDoc=array(setOfWords2Vec(myVocabList,testEntry))  <span class="comment"># 添加测试词组,返回测试词组个总词库索引</span></div><div class="line">    <span class="keyword">print</span> testEntry,<span class="string">'classified as:'</span>,classifyNB(thisDoc, p0V, p1V, pAb)</div><div class="line">    testEntry=[<span class="string">'stupid'</span>,<span class="string">'garbage'</span>]</div><div class="line">    thisDoc=array(setOfWords2Vec(myVocabList,testEntry))</div><div class="line">    <span class="keyword">print</span> testEntry,<span class="string">'classified as:'</span>,classifyNB(thisDoc,p0V,p1V,pAb)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    testingNB()</div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>朴素贝叶斯算法是充分的利用概率原理，用概率的方法分类一个对象的所属类别，对多个类型的对象都可以使用。<br>
算法首先收集了所有训练的词组（数字），通过对总体（比如说文章）的的判断训练，让机器清楚每个的词组出现在总体中分类的概率，用对数的方式防止向下溢出，最终整合概率进行分类。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/08/改善 Python 程序的 91 个建议读书笔记 3/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="王子子">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/large/646083e8jw1e4k8rg9xhdj20ai0am3z6.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="王子子的成长之路">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="王子子的成长之路" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/08/改善 Python 程序的 91 个建议读书笔记 3/" itemprop="url">
                  改善 Python 程序的 91 个建议读书笔记 3
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-08T22:54:00+08:00">
                2017-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="建议-41使用argparse处理命令行参数">建议 41：使用argparse处理命令行参数</h3>
<p>处理命令行参数可以使用argsparse，也推荐更方便更高级的docopt进行处理。<br>
docopt是根据常见的帮助信息定义了一套领域特定语言（DSL），并通过这个DSL Parser参数生成处理命令行参数的代码。</p>
<h3 id="建议-42使用pandas处理大型csv文件">建议 42：使用pandas处理大型CSV文件</h3>
<p>pandas作为python三大科学运算库之一的使用。</p>
<h3 id="建议-43一般情况下使用elementtree解析xml格式文件">建议 43：一般情况下使用ElementTree解析xml格式文件</h3>
<p>使用Beautifulsoup更好</p>
<h3 id="建议-44理解模块pickle优劣">建议 44：理解模块pickle优劣</h3>
<p>序列化，简单来说就是把内存中的数据结构在不丢失其身份和类型信息的情况下转成对象的文本或二进制表示的过程。同类支持序列化的模块有pickle，json，marshal和shelve。</p>
<p>pickle是最通用的序列化模块，我们应该优先使用c语言实现的<strong>cPickle</strong>，速度比pickle快1000倍，区别是cPickle不能被继承。</p>
<p>pickle主要通过dump和load两种方法序列化与反序列化（存储与读取）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle  </div><div class="line"><span class="comment"># 序列化  </span></div><div class="line">my_data= &#123;<span class="string">"name"</span>:<span class="string">"Python"</span>,<span class="string">"type"</span>:<span class="string">"Language"</span>&#125;  </div><div class="line">fp = open(<span class="string">"picklefile.dat"</span>,<span class="string">"wb"</span>)  </div><div class="line">pickle.dump(my_data, fp)  </div><div class="line">fp.close  </div><div class="line">  </div><div class="line"><span class="comment"># 反序列化  </span></div><div class="line">fp = open(<span class="string">"picklefile.dat"</span>, <span class="string">"rb"</span>)  </div><div class="line">out = pickle.load(fp)  </div><div class="line">```  </div><div class="line">pickle模块的优点：  </div><div class="line"><span class="number">1.</span> 接口简单，容易使用。  </div><div class="line"><span class="number">2.</span> 存储格式有平台通用型，在Linux和Windouws都可以使用，兼容性好。  </div><div class="line"><span class="number">3.</span> 支持数据类型广泛，除了常规项，还包含能通过类的\__dict__或\__getstate__()方法返回的对象。  </div><div class="line"><span class="number">4.</span> pickle是可扩展的，对于不可序列化的对象，也可以通过特殊方法来返回示例在被pickle时的状态。  </div><div class="line"><span class="number">5.</span> 能够自动维护对象间的引用  </div><div class="line">  </div><div class="line">pickle模块的限制：  </div><div class="line">* pickle不能保证操作的原子性。当错误发生时，可能部分数据已经被保存；如果对象处于深递归状态，那么可能超过python的最大递归深度，可以通过sys.setrecursionlimit()进行扩展。  </div><div class="line">* pickle存在安全性问题，为乳清提供了可能。  </div><div class="line">* pickle协议是python特定的，不同语言之间数据内容可能难以保障。  </div><div class="line">  </div><div class="line">简单来说，对于需要存储的对象，使用pickle，另外很重要的一点，**dat文件用pickle模块来读**。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 45：序列化的另一个不错的选择 -- JSON  </span></div><div class="line">cJson比python自身的json要快<span class="number">250</span>倍  </div><div class="line">JSON的优势：  </div><div class="line"><span class="number">1.</span> 使用简单，支持多种数据类型（集合、列表、字典、关联数组等等）  </div><div class="line"><span class="number">2.</span> 存储格式可读性更友好，易于修改  </div><div class="line"><span class="number">3.</span> 支持跨平台跨语言操作，所占空间更小  </div><div class="line"><span class="number">4.</span> 具有较强扩展性  </div><div class="line">  </div><div class="line">json的速度比pickle略慢。  </div><div class="line">**json不支持序列化dateime**  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 46：使用 traceback 获取栈信息  </span></div><div class="line">  </div><div class="line">当发生异常，开发人员往往需要看到现场信息，trackback 模块可以满足这个需求，先列几个常用的：  </div><div class="line">  </div><div class="line">```python  </div><div class="line">traceback.print_exc()   <span class="comment"># 打印错误类型、值和具体的trace信息  </span></div><div class="line">traceback.print_exception(type, value, traceback[, limit[, file]])  <span class="comment"># 前三个参数的值可以从sys.exc_info()  </span></div><div class="line">raceback.print_exc([limit[, file]])         <span class="comment"># 同上，不需要传入那么多参数  </span></div><div class="line">traceback.format_exc([limit])               <span class="comment"># 同 print_exc()，返回的是字符串  </span></div><div class="line">traceback.extract_stack([file, [, limit]])  <span class="comment"># 从当前栈中提取 trace 信息  </span></div><div class="line">```  </div><div class="line">  </div><div class="line">traceback 模块获取异常相关的数据是通过sys.exc_info()得到的，该函数返回异常类型type、异常value、调用和堆栈信息traceback组成的元组。  </div><div class="line">  </div><div class="line">同时 inspect 模块也提供了获取 traceback 对象的接口。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 47：使用 logging 记录日志信息  </span></div><div class="line">  </div><div class="line">仅仅将信息输出到控制台是远远不够的，更为常见的是使用日志保存程序运行过程中的相关信息，如运行时间、描述信息以及错误或者异常发生时候的特定上下文信息。Python 提供 logging 模块提供了日志功能。  </div><div class="line">  </div><div class="line">常规日志设置:  </div><div class="line">```python  </div><div class="line">logging.basicConfig(  </div><div class="line">            filename=<span class="string">'%s.log'</span> % self.table_name,  </div><div class="line">            level=logging.DEBUG,  </div><div class="line">            format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,  </div><div class="line">            datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>)  </div><div class="line">```  </div><div class="line">logging是线程安全的，不支持多进程写入同一个子文件，对多个进程需要配置不同的日志文件。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 48：使用 threading 模块编写多线程程序  </span></div><div class="line">（python3中，使用threadpool线程池模块比较省心）  </div><div class="line">由于 GIL 的存在，让 Python 多线程编程在多核处理器中无法发挥优势，但在一些使用场景下使用多线程仍然比较好，如等待外部资源返回，或建立反应灵活的用户界面，或多用户程序等。  </div><div class="line">  </div><div class="line">Python3 提供了两个模块：_thread和threading。_thread提供了底层的多线程支持，使用比较复杂，下面我们重点说说threading。  </div><div class="line">  </div><div class="line">Python 多线程支持用两种方式来创建线程：一种通过继承 Thread 类，重写它的run()方法；另一种是创建一个 threading.Thread 对象，在它的初始化函数__init__()中将可调用对象作为参数传入。  </div><div class="line">  </div><div class="line">threading模块中不仅有 Lock 指令锁，RLock 可重入指令锁，还支持条件变量 Condition、信号量 Semaphore、BoundedSemaphore 以及 Event 事件等。  </div><div class="line">  </div><div class="line">下面有一个比较经典的例子来理解多线程：</div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="keyword">import</span> threading  </div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime,sleep  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">music</span><span class="params">(func)</span>:</span>  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </div><div class="line">        print(<span class="string">"I was listening to %s. %s"</span> % (func,ctime()))  </div><div class="line">        sleep(<span class="number">1</span>)    <span class="comment"># 程序休眠 1 秒  </span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(func)</span>:</span>  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </div><div class="line">        print(<span class="string">"I was at the %s! %s"</span> % (func,ctime()))  </div><div class="line">        sleep(<span class="number">5</span>)  </div><div class="line">  </div><div class="line">threads = []  </div><div class="line">t1 = threading.Thread(target=music,args=(<span class="string">'爱情买卖'</span>,))  </div><div class="line">threads.append(t1)  </div><div class="line">t2 = threading.Thread(target=move,args=(<span class="string">'阿凡达'</span>,))  </div><div class="line">threads.append(t2)  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:  </div><div class="line">        t.setDaemon(<span class="keyword">True</span>)   <span class="comment"># 声明线程为守护线程  </span></div><div class="line">        t.start()  </div><div class="line">    <span class="comment">#3  </span></div><div class="line">    print(<span class="string">"all over %s"</span> % ctime())  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line">以下是运行结果：  </div><div class="line">  </div><div class="line">```python  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">02</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">02</span> <span class="number">2017</span>  </div><div class="line">all over Tue Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">02</span> <span class="number">2017</span>  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line">分析：threading 模块支持线程守护，我们可以通过setDaemon()来设置线程的daemon属性，当其属性为<span class="keyword">True</span>时，表明主线程的退出可以不用等待子线程完成，反之，daemon属性为<span class="keyword">False</span>时所有的非守护线程结束后主线程才会结束，那运行结果为：  </div><div class="line">  </div><div class="line">```python  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">26</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">26</span> <span class="number">2017</span>  </div><div class="line">all over Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">26</span> <span class="number">2017</span>  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">27</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">31</span> <span class="number">2017</span>  </div><div class="line">  </div><div class="line">```  </div><div class="line"></div><div class="line">继续修改代码，当我们在<span class="comment">#3处加入t.join()，此方法能够阻塞当前上下文环境，直到调用该方法的线程终止或到达指定的 timeout，此时在运行程序：  </span></div><div class="line">  </div><div class="line">```python  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">15</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">15</span> <span class="number">2017</span>  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">16</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">20</span> <span class="number">2017</span>  </div><div class="line">all over Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">25</span> <span class="number">2017</span>  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line">当我们把music函数的休眠时间改为 <span class="number">4</span> 秒，再次运行程序：  </div><div class="line">  </div><div class="line">```python</div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">16</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">16</span> <span class="number">2017</span>  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">20</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">21</span> <span class="number">2017</span>  </div><div class="line">all over Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">26</span> <span class="number">2017</span>  </div><div class="line">```  </div><div class="line">此时我们就可以发现多线程的威力了，music虽然增加了 <span class="number">3</span> 秒，然而总的运行时间仍然为 <span class="number">10</span> 秒。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 49：使用 Queue 使多线程编程更加安全  </span></div><div class="line">（同<span class="number">47</span>，使用threadingpool）  </div><div class="line">线程间的同步和互斥，线程间数据的共享等这些都是涉及线程安全要考虑的问题。纵然 Python 中提供了众多的同步和互斥机制，如 mutex、condition、event 等，但同步和互斥本身就不是一个容易的话题，稍有不慎就会陷入死锁状态或者威胁线程安全。  </div><div class="line">  </div><div class="line">如何保证线程安全呢？我们先来看看 Python 中的 Queue 模块：  </div><div class="line">  </div><div class="line">* Queue.Queue(maxsize)：先进先出，maxsize 为队列大小，其值为非正数的时候为无限循环队列  </div><div class="line">* Queue.LifoQueue(maxsize)：后进先出，相当于栈  </div><div class="line">* Queue.PriorityQueue(maxsize)：优先级队列  </div><div class="line">  </div><div class="line">以上队列所支持的方法：  </div><div class="line">  </div><div class="line">* Queue.qsize()：返回近似的队列大小。当该值 &gt; <span class="number">0</span> 的时候并不保证并发执行的时候 get() 方法不被阻塞，同样，对于 put() 方法有效。  </div><div class="line">* Queue.empty()：队列为空的时候返回 <span class="keyword">True</span>，否则返回 <span class="keyword">False</span>  </div><div class="line">* Queue.full()：当设定了队列大小的情况下，如果队列满则返回 <span class="keyword">True</span>，否则返回 <span class="keyword">False</span>  </div><div class="line">* Queue.put(item[, block[, timeout]])：往队列中添加元素 item，block 设置为 <span class="keyword">False</span> 的时候，如果队列满则抛出 Full 异常。如果 block 设置为 <span class="keyword">True</span>，timeout 为 <span class="keyword">None</span> 的时候则会一直等待直到有空位置，否则会根据 timeout 的设定超时后抛出 Full 异常  </div><div class="line">* Queue.put_nowait(item)：等于 put(item, <span class="keyword">False</span>).block 设置为 <span class="keyword">False</span> 的时候，如果队列空则抛出 Empty 异常。如果 block 设置为 <span class="keyword">True</span>、timeout 为 <span class="keyword">None</span> 的时候则会一直等到有元素可用，否则会根据 timeout 的设定超时后抛出 Empty 异常  </div><div class="line">* Queue.get([block[, timeout]])：从队列中删除元素并返回该元素的值  </div><div class="line">* Queue.get_nowait()：等价于 get(<span class="keyword">False</span>)  </div><div class="line">* Queue.task_done()：发送信号表明入列任务已经完成，经常在消费者线程中用到  </div><div class="line">* Queue.join()：阻塞直至队列中所有的元素处理完毕  </div><div class="line">首先 Queue 中的队列和 collections.deque 所表示的队列并不一样，前者用于不同线程之间的通信，内部实现了线程的锁机制，后者是数据结构上的概念，支持 <span class="keyword">in</span> 方法。  </div><div class="line">  </div><div class="line">Queue 模块实现了多个生产者多个消费者的队列，当多线程之间需要信息安全的交换的时候特别有用，因此这个模块实现了所需要的锁原语，为 Python 多线程编程提供了有力的支持，它是线程安全的。  </div><div class="line">  </div><div class="line">先来看一个简单的例子：  </div><div class="line">```python  </div><div class="line"><span class="keyword">import</span> os  </div><div class="line"><span class="keyword">import</span> Queue  </div><div class="line"><span class="keyword">import</span> threading  </div><div class="line"><span class="keyword">import</span> urllib2  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span><span class="params">(threading.Thead)</span>:</span>  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span>  </div><div class="line">        threading.Thread.__init__(self)  </div><div class="line">        self.queue = queue  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:  </div><div class="line">            url = self.queue.get()  </div><div class="line">            print(<span class="string">'&#123;0&#125; begin download &#123;1&#125;...'</span>.format(self.name, url))  </div><div class="line">            self.download_file(url)  </div><div class="line">            self.queque.task_done()  </div><div class="line">            print(<span class="string">'&#123;0&#125; download completed!!!'</span>.format(self.name))  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download_file</span><span class="params">(self, url)</span>:</span>  </div><div class="line">        urlhandler = urllib2.urlopen(url)  </div><div class="line">        fname = os.path.basename(url) + <span class="string">'.html'</span>  </div><div class="line">        <span class="keyword">with</span> open(fname, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  </div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:  </div><div class="line">                chunk = urlhandler.read(<span class="number">1024</span>)  </div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> chunk: <span class="keyword">break</span>  </div><div class="line">                f.write(chunk)  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </div><div class="line">    urls = [<span class="string">'http://wiki.python.org/moin/WebProgramming'</span>,  </div><div class="line">            <span class="string">'https://www.createspace.com/3611970'</span>,  </div><div class="line">            <span class="string">'http://wiki.python.org/moin/Documentation'</span>  </div><div class="line">    ]  </div><div class="line">    queue = Queue.Queue()  </div><div class="line">    <span class="keyword">for</span> i range(<span class="number">5</span>):  </div><div class="line">        t = DownloadThread(queue)  </div><div class="line">        t.setDaemon(<span class="keyword">True</span>)  </div><div class="line">        t.start()  </div><div class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:  </div><div class="line">        queue.put(url)  </div><div class="line">    queue.join()  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line"><span class="comment">## 第 5 章 设计模式  </span></div><div class="line"><span class="comment">### 建议 50：利用模块实现单例模式  </span></div><div class="line">单例模式可以保证徐彤中一个类只有一个实例且该实例易被外界访问，常用来使用XxxManager之类的功能。  </div><div class="line">  </div><div class="line">满足单例模式的 <span class="number">3</span> 个需求：  </div><div class="line">  </div><div class="line">* 只能有一个实例  </div><div class="line">* 必须自行创建这个实例  </div><div class="line">* 必须自行向整个系统提供这个实例  </div><div class="line">  </div><div class="line">模块采用的其实是天然的单例的实现方式，在入口文件导入：  </div><div class="line">* 所有的变量都会绑定到模块  </div><div class="line">* 模块只初始化一次  </div><div class="line">* <span class="keyword">import</span> 机制是线程安全的，保证了在并发状态下模块也只是一个实例  </div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="comment"># World.py  </span></div><div class="line"><span class="keyword">import</span> Sun  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span>  </div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  </div><div class="line">        Sun.rise()  </div><div class="line">        Sun.set()  </div><div class="line">  </div><div class="line"><span class="comment"># main.py  </span></div><div class="line"><span class="keyword">import</span> World  </div><div class="line">World.run()  </div><div class="line">```  </div><div class="line">  </div><div class="line">此外，Borg模式可以创造任意数量实例，并保证状态共享。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 51：用 mixin 模式让程序更加灵活  </span></div><div class="line">模板方法模式就是在一个方法中定义一个算法的骨架，并将一些实现步骤延迟到子类中。模板方法可以使子类在不改变算法结构的情况下，重新定义算法中的某些步骤。  </div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseSimpleTeapot</span><span class="params">(object)</span>:</span>  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_teapot</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">return</span> SimpleTeapot()  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseKungfuTeapot</span><span class="params">(object)</span>:</span>  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_teapot</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">return</span> KungfuTeapot()  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficePeople</span><span class="params">(People, UseSimpleTeapot)</span>:</span> <span class="keyword">pass</span>  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePeople</span><span class="params">(People, UseSimpleTeapot)</span>:</span> <span class="keyword">pass</span>  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span><span class="params">(People, UseKungfuTeapot)</span>:</span> <span class="keyword">pass</span>  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_tea_people</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    people.__base__ += (UseSimpleTeapot,)  </div><div class="line">    <span class="keyword">return</span> people  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">coffee_people</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    people.__base__ += (UseCoffeepot,)  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tea_and_coffee_people</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    people.__base__ += (UseSimpleTeapot, UserCoffeepot,)  </div><div class="line">    <span class="keyword">return</span> people  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">boss</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    people.__base__ += (KungfuTeapot, UseCoffeepot, )  </div><div class="line">    <span class="keyword">return</span> people  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line">代码的原理在于每个类都有一个__bases__属性，它是一个元组，用来存放所有的基类，作为动态语言，Python 中的基类可以在运行中可以动态改变。所以当我们向其中增加新的基类时，这个类就拥有了新的方法，这就是混入mixin。  </div><div class="line">  </div><div class="line">利用这个技术我们可以在不修改代码的情况下就可以完成需求：  </div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="keyword">import</span> mixins   <span class="comment"># 把员工需求定义在 Mixin 中放在 mixins 模块  </span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">staff</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    bases = []  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> config.checked():  </div><div class="line">        bases.append(getattr(maxins, i))  </div><div class="line">    people.__base__ += tuple(bases)  </div><div class="line">    <span class="keyword">return</span> people  </div><div class="line">  </div><div class="line">```  </div><div class="line"></div><div class="line"><span class="comment">### 建议 52：用发布订阅模式实现松耦合  </span></div><div class="line">  </div><div class="line">发布订阅模式是一种编程模式，消息的发送者不会发送其消息给特定的接收者，而是将发布的消息分为不同的类别直接发布，并不关注订阅者是谁。而订阅者可以对一个或多个类别感兴趣，且只接收感兴趣的消息，并且不关注是哪个发布者发布的消息。要实现这个模式，就需要一个中间代理人。   Broker，它维护着发布者和订阅者的关系，订阅者把感兴趣的主题告诉它，而发布者的信息也通过它路由到各个订阅者处。  </div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  </div><div class="line">route_table = defaultdict(list)  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(topic, callback)</span>:</span>  </div><div class="line">    <span class="keyword">if</span> callback <span class="keyword">in</span> route_table[topic]:  </div><div class="line">        <span class="keyword">return</span>  </div><div class="line">    route_table[topic].append(callback)  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pub</span><span class="params">(topic, *args, **kw)</span>:</span>  </div><div class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> route_table[topic]:  </div><div class="line">        func(*args, **kw)  </div><div class="line">  </div><div class="line">```  </div><div class="line">将以上代码放在 Broker.py 的模块，省去了各种参数检测、优先处理、取消订阅的需求，只向我们展示发布订阅模式的基础实现：  </div><div class="line">  </div><div class="line">```python</div><div class="line"><span class="keyword">import</span> Broker</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'Hello, &#123;&#125;'</span>.format(name))  </div><div class="line">Broker.sub(<span class="string">'greet'</span>, greeting)</div><div class="line">Broker.pub(<span class="string">'greet'</span>, <span class="string">'LaiYonghao'</span>)</div></pre></td></tr></table></figure>
<p>因为python-message的消息订阅默认是全局性的，所以有可能产生名字冲突。</p>
<h3 id="建议-53用状态模式美化代码">建议 53：用状态模式美化代码</h3>
<p>所谓状态模式，就是当一个对象的内在状态改变时允许改变其行为，但这个对象看起来像是改变了其类。</p>
<p>简单的状态模式有其缺点：</p>
<ul>
<li>查询对象的当前状态很麻烦<br>
</li>
<li>状态切换时需要对原状态做一些清扫工作，而对新状态做初始化工作，因每个状态需要做的事情不同，全部写在切换状态的代码中必然重复</li>
</ul>
<p>这时候我们可以使用 Python-state 来解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> state <span class="keyword">import</span> curr, switch, stateful, State, behavior</div><div class="line"><span class="meta">@stateful</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Workday</span><span class="params">(State)</span>:</span></div><div class="line">        default = <span class="keyword">True</span></div><div class="line"><span class="meta">        @behavior   # 相当于staticmethod</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(self)</span>:</span>  <span class="comment"># 这里的self并不是Python的关键字，而是有助于我们理解状态类的宿主是People的实例</span></div><div class="line">            print(<span class="string">'work hard'</span>)</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Weekend</span><span class="params">(State)</span>:</span></div><div class="line"><span class="meta">        @behavior</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(self)</span>:</span></div><div class="line">            print(<span class="string">'play harder'</span>)</div><div class="line">people = People()</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>):</div><div class="line">        <span class="keyword">if</span> i == <span class="number">6</span>:</div><div class="line">            switch(people, People.Weekend)</div><div class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</div><div class="line">            switch(people, People.Workday)</div><div class="line">        people.day()</div></pre></td></tr></table></figure>
<p><span class="citation">@statefule装饰器重载了被修饰的类的__getattr__</span>()从而使得 People 的实例能够调用当前状态类的方法，同时被修饰的类的实例是带有状态的，能够使用curr()查询当前状态，也可以使用switch()进行状态切换，默认的状态是通过类定义的 default 属性标识，default = True的类成为默认状态。</p>
<p>状态类 Workday 和 Weekend 继承自 State 类，从其派生的子类可以使用__begin__和__end___状态转换协议，自定义进入和离开当前状态时对宿主的初始化和清理工作。</p>
<p>下面是一个真实业务的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@stateful</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NeedSignin</span><span class="params">(State)</span>:</span></div><div class="line">        default = <span class="keyword">True</span></div><div class="line"><span class="meta">        @behavior</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">signin</span><span class="params">(self, user, pwd)</span>:</span></div><div class="line">            ...</div><div class="line">            switch(self, Player.Signin)</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Signin</span><span class="params">(State)</span>:</span></div><div class="line"><span class="meta">        @behavior</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, dst)</span>:</span> ...</div><div class="line"><span class="meta">        @behavior</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">atk</span><span class="params">(self, other)</span>:</span> ...</div></pre></td></tr></table></figure>
<h2 id="第-6-章-内部机制">第 6 章 内部机制</h2>
<h3 id="建议-54理解-built-in-objects">建议 54：理解 built-in objects</h3>
<p>Python 中一切皆对象，在新式类中，object 是所有内建类型的基类，用户自定义的类可以继承自 object 也可继承自内建类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">TestNewClass</span>:</span></div><div class="line">   ...:     __metaclass__ = type</div><div class="line">   ...:     </div><div class="line"></div><div class="line">In [<span class="number">2</span>]: type(TestNewClass)</div><div class="line">Out[<span class="number">2</span>]: type</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: TestNewClass.__bases__</div><div class="line">Out[<span class="number">3</span>]: (object,)</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: a = TestNewClass()</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: type(a)</div><div class="line">Out[<span class="number">5</span>]: __main__.TestNewClass</div><div class="line"></div><div class="line">In [<span class="number">6</span>]: a.__class__</div><div class="line">Out[<span class="number">6</span>]: __main__.TestNewClass</div></pre></td></tr></table></figure>
<p>新式类支持 property 和描述符特性，作为新式类的祖先，Object 类还定义了一些特殊方法：<strong>new</strong>()、<strong>init</strong>()、<strong>delattr</strong>()、<strong>getattribute</strong>()、<strong>setattr</strong>()、<strong>hash</strong>()、<strong>repr</strong>()、<strong>str</strong>()等。</p>
<h3 id="建议-55init不是构造方法">建议 55：<strong>init</strong>()不是构造方法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></div><div class="line">        print(cls)</div><div class="line">        print(args)</div><div class="line">        print(kw)</div><div class="line">        print(<span class="string">'----------'</span>)</div><div class="line">        instance = object.__new__(cls, *args, **kw)</div><div class="line">        print(instance)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></div><div class="line">        print(<span class="string">'init gets called'</span>)</div><div class="line">        print(<span class="string">'self is &#123;&#125;'</span>.format(self))</div><div class="line">        self.a, self.b = a, b</div><div class="line">a1 = A(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">print(a1.a)</div><div class="line">print(a1.b)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;class '__main__.A'&gt;</div><div class="line">(1, 2)</div><div class="line">&#123;&#125;</div><div class="line">----------</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "test.py", line 19, in &lt;module&gt;</div><div class="line">    a1 = A(1, 2)</div><div class="line">  File "test.py", line 13, in __new__</div><div class="line">    instance = object.__new__(cls, *args, **kw)</div><div class="line">TypeError: object() takes no parameters</div></pre></td></tr></table></figure>
<p>从结果中我们可以看出，程序输出了__new__()调用所产生的输出，并抛出了异常。于是我们知道，原来__new__()才是真正创建实例，是类的构造方法，而__init__()是在类的对象创建好之后进行变量的初始化。上面程序抛出异常是因为在__new__()中没有显式返回对象，a1此时为None，当去访问实例属性时就抛出了异常。</p>
<p>根据官方文档，我们可以总结以下几点：</p>
<ul>
<li>object.<strong>new</strong>(cls[, args…])：其中 cls 代表类，args 为参数列表，为静态方法<br>
</li>
<li>object.<strong>init</strong>(self[, args…])：其中 self 代表实例对象，args 为参数列表，为实例方法<br>
</li>
<li>控制实例创建的时候可使用 <strong>new</strong>() ，而控制实例初始化的时候使用 <strong>init</strong>()</li>
<li><strong>new</strong>()需要返回类的对象，当返回类的对象时将会自动调用__init__()进行初始化，没有对象返回，则__init__()不会被调用。<strong>init</strong>() 方法不需要显示返回，默认为 None，否则会在运行时抛出 TypeError<br>
</li>
<li>但当子类继承自不可变类型，如 str、int、unicode 或者 tuple 的时候，往往需要覆盖__new__()<br>
</li>
<li>覆盖 <strong>new</strong>() 和 <strong>init</strong>() 的时候这两个方法的参数必须保持一致，如果不一致将导致异常<br>
下面我们来总结需要覆盖__new__()的几种特殊情况：<br>
</li>
<li>当类继承不可变类型且默认的 <strong>new</strong>() 方法不能满足需求的时候<br>
</li>
<li>用来实现工厂模式或者单例模式或者进行元类编程，使用__new__()来控制对象创建<br>
</li>
<li>作为用来初始化的 <strong>init</strong>() 方法在多继承的情况下，子类的 <strong>init</strong>()方法如果不显式调用父类的 <strong>init</strong>() 方法，则父类的 <strong>init</strong>() 方法不会被调用；通过super(子类， self).<strong>init</strong>()显式调用父类的初始化方法；对于多继承的情况，我们可以通过迭代子类的 <strong>bases</strong> 属性中的内容来逐一调用父类的初始化方法</li>
</ul>
<p>分别来看例子加深理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个集合能够将任何以空格隔开的字符串变为集合中的元素</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSet</span><span class="params">(frozenset)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args)</span>:</span></div><div class="line">        <span class="keyword">if</span> args <span class="keyword">and</span> isinstance(args[<span class="number">0</span>], str):</div><div class="line">            args = (args[<span class="number">0</span>].split(), ) + args[<span class="number">1</span>:]</div><div class="line">        <span class="keyword">return</span> super(UserSet, cls).__new__(cls, *args)</div><div class="line"></div><div class="line"><span class="comment"># 一个工厂类根据传入的参量决定创建出哪一种产品类的实例</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span><span class="params">(Shape)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am a triangle"</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am drawing triangle"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(Shape)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am a rectangle"</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am drawing triangle"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trapezoid</span><span class="params">(Shape)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am a trapezoid"</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am drawing triangle"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Diamond</span><span class="params">(Shape)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am a diamond"</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am drawing triangle"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span><span class="params">(object)</span>:</span></div><div class="line">    shapes = &#123;<span class="string">'triangle'</span>: Triangle, <span class="string">'rectangle'</span>: Rectangle, <span class="string">'trapzoid'</span>: Trapezoid, <span class="string">'diamond'</span>: Diamond&#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name)</span>:</span></div><div class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> ShapeFactory.shapes.keys():</div><div class="line">            print(<span class="string">'creating a new shape &#123;&#125;'</span>.format(name))</div><div class="line">            <span class="keyword">return</span> ShapeFactory.shapes[name]()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'creating a new shape &#123;&#125;'</span>.format(name))</div><div class="line">            <span class="keyword">return</span> Shape()</div></pre></td></tr></table></figure>
<h3 id="建议-56理解名字查找机制">建议 56：理解名字查找机制</h3>
<p>在 Python 中所谓的变量其实都是名字，这些名字指向一个或多个 Python 对象。这些名字都存在于一个表中（命名空间），我们称之为局部变量，调用locals()可以查看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; locals()</div><div class="line">&#123;'__package__': None, '__spec__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__doc__': None, '__name__': '__main__', '__builtins__': &lt;module 'builtins' (built-in)&gt;&#125;</div><div class="line">&gt;&gt;&gt; globals()</div><div class="line">&#123;'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__package__': None, '__doc__': None, '__spec__': None, '__name__': '__main__'&#125;</div></pre></td></tr></table></figure>
<p>Python 中的作用域分为：</p>
<ul>
<li>局部作用域: 一般来说函数的每次调用都会创建一个新的本地作用域, 拥有新的命名空间<br>
</li>
<li>全局作用域: 定义在 Python 模块文件中的变量名拥有全局作用域, 即在一个文件的顶层的变量名仅在这个文件内可见<br>
</li>
<li>嵌套作用域: 多重函数嵌套时才会考虑, 即使使用 global 进行申明也不能达到目的, 其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量<br>
</li>
<li>内置作用域: 通过标准库中的__builtin__实现的 当访问一个变量的时候，其查找顺序遵循变量解析机制 LEGB 法则，即依次搜索 4 个作用域：局部作用域、嵌套作用域、全局作用域以及内置作用域，并在第一个找到的地方停止搜寻，如果没有搜到，则会抛出异常。</li>
</ul>
<p>Python 3 中引入了 nonlocal 关键字:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></div><div class="line">    a = x</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> a</div><div class="line">        b = a * <span class="number">2</span></div><div class="line">        a = b + <span class="number">1</span></div><div class="line">        print(a)</div><div class="line">    <span class="keyword">return</span> bar</div></pre></td></tr></table></figure>
<h3 id="建议-57-为什么需要-self-参数">建议 57: 为什么需要 self 参数</h3>
<p>在类中当定义实例方法的时候需要将第一个参数显式声明为self, 而调用时不需要传入该参数, 我们通过self.x访问实例变量, self.m()访问实例方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfTest</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self.name)</span>:</span></div><div class="line">        self.name = name</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showself</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'self here is &#123;&#125;'</span>.format(self))</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></div><div class="line">        self.showself()</div><div class="line">        print(<span class="string">'The name is: &#123;&#125;'</span>.format(self.name))</div><div class="line">st = SelfTest(<span class="string">'instance self'</span>)</div><div class="line">st.display()</div><div class="line">print(<span class="string">'&#123;&#125;'</span>.format(st))</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self here <span class="keyword">is</span> &lt;__main__.SelfTest object at <span class="number">0x7f440c53ba58</span>&gt;</div><div class="line">The name <span class="keyword">is</span>: instance self</div><div class="line">&lt;__main__.SelfTest object at <span class="number">0x7f440c53ba58</span>&gt;</div></pre></td></tr></table></figure>
<p>从中可以发现, self 表示实例对象本身, 即 SelfTest 类的对象在内存中的地址. self 是对对象 st 本身的引用, 我们在调用实例方法时也可以直接传入实例对象: SelfTest.display(st). 同时 self 或 cls 并不是 Python 的关键字, 可以替换成其它的名称。</p>
<p>Python 中为什么需要 self 呢:</p>
<ol style="list-style-type: decimal">
<li>借鉴了其他语言的特征</li>
<li>Python 语言本身的动态性决定了使用 self 能够带来一定便利<br>
</li>
<li>在存在同名的局部变量以及实例变量的情况下使用 self 使得实例变量更容易被区分</li>
</ol>
<p>Python 属于一级对象语言, 我们有好几种方法可以引用类方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A.__dict__[<span class="string">"m"</span>]</div><div class="line">A.m.__func__</div></pre></td></tr></table></figure>
<p>Python 的哲学是：显示优于隐式（Explicit is better than implicit）。</p>
<h3 id="建议-58-理解-mro-与多继承">建议 58: 理解 MRO 与多继承</h3>
<p>古典类与新式类所采取的 MRO (Method Resolution Order, 方法解析顺序) 的实现方式存在差异。</p>
<p>古典类是按照多继承申明的顺序形成继承树结构, 自顶向下采用深度优先的搜索顺序. 而新式类采用的是 C3 MRO 搜索方法, 在新式类通过__mro__得到 MRO 的搜索顺序, C3 MRO 的算法描述如下:</p>
<blockquote>
<p>假定，C1C2…CN 表示类 C1 到 CN 的序列，其中序列头部元素（head）=C1，序列尾部（tail）定义 = C2…CN；</p>
<p>C 继承的基类自左向右分别表示为 B1，B2…BN</p>
<p>L[C] 表示 C 的线性继承关系，其中 L[object] = object。</p>
<p>算法具体过程如下：</p>
<p>L[C(B1…BN)] = C + merge(L[B1] … L[BN], B1 … BN)</p>
<p>其中 merge 方法的计算规则如下：在 L[B1]…L[BN]，B1…BN 中，取 L[B1] 的 head，如果该元素不在 L[B2]…L[BN]，B1…BN 的尾部序列中，则添加该元素到 C 的线性继承序列中，同时将该元素从所有列表中删除（该头元素也叫 good head），否则取 L[B2] 的 head。继续相同的判断，直到整个列表为空或者没有办法找到任何符合要求的头元素（此时，将引发一个异常）。</p>
</blockquote>
<p>菱形继承是我们在多继承设计的时候需要尽量避免的一个问题。</p>
<h3 id="建议-59-理解描述符机制">建议 59: 理解描述符机制</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">   ...:     class_attr = <span class="number">1</span></div><div class="line">   ...:     </div><div class="line"><span class="comment"># 每一个类都有一个__dict__属性, 包含它的所有属性</span></div><div class="line">In [<span class="number">2</span>]: MyClass.__dict__</div><div class="line">Out[<span class="number">2</span>]:</div><div class="line">mappingproxy(&#123;<span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'MyClass'</span> objects&gt;,</div><div class="line">              <span class="string">'__doc__'</span>: <span class="keyword">None</span>,</div><div class="line">              <span class="string">'__module__'</span>: <span class="string">'__main__'</span>,</div><div class="line">              <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'MyClass'</span> objects&gt;,</div><div class="line">              <span class="string">'class_attr'</span>: <span class="number">1</span>&#125;)</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: my_instance = MyClass()</div><div class="line"><span class="comment"># 每一个实例也相应有一个实例属性, 我们通过实例访问一个属性时,</span></div><div class="line"><span class="comment"># 它首先会尝试在实例属性中查找, 找不到会到类属性中查找</span></div><div class="line">In [<span class="number">4</span>]: my_instance.__dict__</div><div class="line">Out[<span class="number">4</span>]: &#123;&#125;</div><div class="line"><span class="comment"># 实例访问类属性</span></div><div class="line">In [<span class="number">5</span>]: my_instance.class_attr</div><div class="line">Out[<span class="number">5</span>]: <span class="number">1</span></div><div class="line"><span class="comment"># 如果通过实例增加一个属性,只能改变此实例的属性</span></div><div class="line">In [<span class="number">6</span>]: my_instance.inst_attr = <span class="string">'china'</span></div><div class="line"></div><div class="line">In [<span class="number">7</span>]: my_instance.__dict__</div><div class="line">Out[<span class="number">7</span>]: &#123;<span class="string">'inst_attr'</span>: <span class="string">'china'</span>&#125;</div><div class="line"><span class="comment"># 对于类属性而言并没有丝毫变化</span></div><div class="line">In [<span class="number">8</span>]: MyClass.__dict__</div><div class="line">Out[<span class="number">8</span>]:</div><div class="line">mappingproxy(&#123;<span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'MyClass'</span> objects&gt;,</div><div class="line">              <span class="string">'__doc__'</span>: <span class="keyword">None</span>,</div><div class="line">              <span class="string">'__module__'</span>: <span class="string">'__main__'</span>,</div><div class="line">              <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'MyClass'</span> objects&gt;,</div><div class="line">              <span class="string">'class_attr'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="comment"># 我们可以动态地给类增加一个属性</span></div><div class="line">In [<span class="number">9</span>]: MyClass.class_attr2 = <span class="number">100</span></div><div class="line"></div><div class="line">In [<span class="number">10</span>]: my_instance.class_attr2</div><div class="line">Out[<span class="number">10</span>]: <span class="number">100</span></div><div class="line"><span class="comment"># 但Python的内置类型并不能随意地为它增加属性或方法</span></div></pre></td></tr></table></figure>
<p>.操作符封装了对实例属性和类属性两种不同属性进行查找的细节。</p>
<p>但是如果是访问方法呢:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">my_method</span><span class="params">(self)</span>:</span></div><div class="line">   ...:         print(<span class="string">'my_method'</span>)</div><div class="line">   ...:         </div><div class="line"></div><div class="line">In [<span class="number">2</span>]: MyClass.__dict__[<span class="string">'my_method'</span>]</div><div class="line">Out[<span class="number">2</span>]: &lt;function __main__.MyClass.my_method&gt;</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: MyClass.my_method</div><div class="line">Out[<span class="number">3</span>]: &lt;function __main__.MyClass.my_method&gt;</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: type(MyClass.my_method)</div><div class="line">Out[<span class="number">4</span>]: function</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: type(MyClass.__dict__[<span class="string">'my_method'</span>])</div><div class="line">Out[<span class="number">5</span>]: function</div></pre></td></tr></table></figure>
<p>根据通过实例访问属性和根据类访问属性的不同，有以下两种情况：</p>
<ul>
<li><p>一种是通过实例访问，比如代码 obj.x，如果 x 是一个描述符，那么 <strong>getattribute</strong>() 会返回 type(obj).<strong>dict</strong>[‘x’].<strong>get</strong>(obj, type(obj)) 结果，即：type(obj) 获取 obj 的类型；type(obj).<strong>dict</strong>[‘x’] 返回的是一个描述符，这里有一个试探和判断的过程；最后调用这个描述符的 <strong>get</strong>() 方法。</p></li>
<li><p>另一个是通过类访问的情况，比如代码 cls.x，则会被 <strong>getattribute</strong>()转换为 cls.<strong>dict</strong>[‘x’].<strong>get</strong>(None, cls)。</p>
<p>描述符协议是一个 Duck Typing 的协议，而每一个函数都有 <strong>get</strong> 方法，也就是说其他每一个函数都是描述符。所有对属性, 方法进行修饰的方案往往都用到了描述符, 如classmethod, staticmethod, property等, 以下是property的参考实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"Emulate PyProperty_Type() in Objects/descrobject.c"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></div><div class="line">        self.fget = fget</div><div class="line">        self.fset = fset</div><div class="line">        self.fdel = fdel</div><div class="line">        self.__doc__ = doc</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"unreadable attribute"</span></div><div class="line">        <span class="keyword">return</span> self.fget(obj)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't set attribute"</span></div><div class="line">        self.fset(obj, value)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't delete attribute"</span></div><div class="line">        self.fdel(obj)</div></pre></td></tr></table></figure></li>
</ul>
<h3 id="建议-60区别__getattr__和__getattribute__方法">建议 60：区别__getattr__()和__getattribute__()方法</h3>
<p>以上两种方法可以对实例属性进行获取和拦截：</p>
<ul>
<li><strong>getattr</strong>(self, name)：适用于属性在实例中以及对应的类的基类以及祖先类中都不存在；<br>
</li>
<li><strong>getattribute</strong>(self, name)：对于所有属性的访问都会调用该方法。</li>
</ul>
<p>但访问不存在的实例属性时，会由内部方法__getattribute__()抛出一个 AttributeError 异常，也就是说只要涉及实例属性的访问就会调用该方法，它要么返回实际的值，要么抛出异常。详情请<a href="http://link.zhihu.com/?target=http%3A//docs.python.org/2/reference/datamodel.html%23object.getattribute" target="_blank" rel="external">参考</a>。</p>
<p>那么__getattr__()在什么时候调用呢：</p>
<ul>
<li>属性不在实例的__dict__中；<br>
</li>
<li>属性不在其基类以及祖先类的__dict__中；<br>
</li>
<li>触发AttributeError异常时（注意，不仅仅是__getattribute__()方法的AttributeError异常，property 中定义的get()方法抛出异常的时候也会调用该方法）。</li>
</ul>
<p>当这两个方法同时被定义的时候，要么在__getattribute__()中显式调用，要么触发AttributeError异常，否则__getattr__()永远不会被调用。</p>
<p>我们知道 property 也能控制属性的访问，如果一个类中如果定义了 property、<strong>getattribute</strong>()以及__getattr__()来对属性进行访问控制，会最先搜索__getattribute__()方法，由于 property 对象并不存在于 dict 中，因此并不能返回该方法，此时会搜索 property 中的get()方法；当 property 中的set()方法对属性进行修改并再次访问 property 的get()方法会抛出异常，这时会触发__getattr__()的调用。</p>
<blockquote>
<p><strong>getattribute</strong>()总会被调用，而__getattr__()只有在__getattribute__()中引发异常的情况下调用。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/26/改善 Python 程序的 91 个建议读书笔记 2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="王子子">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/large/646083e8jw1e4k8rg9xhdj20ai0am3z6.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="王子子的成长之路">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="王子子的成长之路" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/26/改善 Python 程序的 91 个建议读书笔记 2/" itemprop="url">
                  改善 Python 程序的 91 个建议读书笔记 2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T23:14:29+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="建议-21-i1-不等于-i">建议 21： i+=1 不等于 ++i</h3>
<p>++i 合法，但是无效</p>
<h3 id="建议-22使用-with-自动关闭资源">建议 22：使用 with 自动关闭资源</h3>
<p>对于打开的资源我们记得关闭它，如文件、数据库连接等，Python 提供了一种简单优雅的解决方案：with。</p>
<p>with的实现得益于一个称为上下文管理器(context manager)的东西，它定义程序运行时需要建立的上下文，处理程序的进入和退出，实现了上下文管理协议，即对象中定义了__enter__()和__exit__()，任何实现了上下文协议的对象都可以称为一个上下文管理器：</p>
<ul>
<li><strong>enter</strong>()：返回运行时上下文相关的对象<br>
</li>
<li><strong>exit</strong>(exception_type, exception_value, traceback)：退出运行时的上下文，处理异常、清理现场等</li>
</ul>
<p>包含with语句的代码块执行过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line"><span class="meta">... </span>    f.write(<span class="string">'test'</span>)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.__enter__</div><div class="line">&lt;built-<span class="keyword">in</span> method __enter__ of _io.TextIOWrapper object at <span class="number">0x7f1b967aaa68</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.__exit__</div><div class="line">&lt;built-<span class="keyword">in</span> method __exit__ of _io.TextIOWrapper object at <span class="number">0x7f1b967aaa68</span>&gt;</div></pre></td></tr></table></figure>
<ol style="list-style-type: decimal">
<li>计算表达式的值，返回一个上下文管理器对象。<br>
</li>
<li>加载上下文管理器对象的__exit__()以备后用。<br>
</li>
<li>调用上下文管理器对象的__enter__()。<br>
</li>
<li>将__enter__()的返回值赋给目标对象。<br>
</li>
<li>执行代码块，正常结束调用__exit__()，其返回值直接忽略，如果发生异常，会调用__exit__()并将异常类型、值及 traceback 作为参数传递给__exit__()，<strong>exit</strong>()返回值为 false 异常将会重新抛出，返回值为 true 异常将被挂起，程序继续执行。</li>
</ol>
<p>Python 还提供 contextlib 模块，通过 Generator 实现，其中的 contextmanager 作为装饰器来提供一种针对函数级别上的上下文管理器，可以直接作用于函数/对象而不必关心__enter__()和__exit__()的实现。</p>
<p><a href="http://link.zhihu.com/?target=http%3A//www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001478651770626de401ff1c0d94f379774cabd842222ff000" target="_blank" rel="external">推荐文章</a></p>
<h3 id="建议-23使用-else-子句简化循环异常处理">建议 23：使用 else 子句简化循环（异常处理）</h3>
<p>python 的 else 子句在循环正常结束和循环条件不成立时被执行，由 break 语句中断时不执行，同样，我们可以利用这颗语法糖作用在 while 和 try…except 中。</p>
<h3 id="建议-24遵循异常处理的几点基本原则">建议 24：遵循异常处理的几点基本原则</h3>
<p>异常处理的几点原则：<br>
1. 注意异常的粒度，不推荐在 try 中放入过多的代码。 2. 谨慎使用单独的 except 语句处理所有异常，最好能定位具体的异常。<br>
3. 注意异常捕获的顺序，在适合的层次处理异常，Python 是按内建异常类的继承结构处理异常的，所以推荐的做法是将继承结构中子类异常在前抛出，父类异常在后抛出。<br>
4. 使用更为友好的异常信息，遵守异常参数的规范。</p>
<h3 id="建议-25避免-finally-中可能发生的陷阱">建议 25：避免 finally 中可能发生的陷阱</h3>
<p>当 finally 执行完毕时，之前临时保存的异常将会再次被抛出，但如果 finally 语句中产生了新的异常或执行了 return 或 break 语句，那么临时保存的异常将会被丢失，从而异常被屏蔽。 在实际开发中不推荐 finally 中使用 return 语句进行返回。</p>
<h3 id="建议-26深入理解-none正确判断对象是否为空">建议 26：深入理解 None，正确判断对象是否为空</h3>
<p>（None被判断为False，但是空集不等于None）<br>
类型FalseTrue布尔False （与0等价）True （与1等价）字符串“”（ 空字符串）非空字符串，例如 &quot; “,”blog“数值0, 0.0非0的数值，例如：1, 0.1, -1, 2容器[], (), {}, set()至少有一个元素的容器对象，例如：[0], (None,), [’’]NoneNone非None对象。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="bu">id</span>(<span class="va">None</span>)  
<span class="dv">10743840</span>  
<span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> <span class="va">None</span>  
<span class="op">&gt;&gt;&gt;</span> <span class="bu">id</span>(a)  
<span class="dv">10743840</span>  
<span class="op">&gt;&gt;&gt;</span> l <span class="op">=</span> []  
<span class="op">&gt;&gt;&gt;</span> <span class="cf">if</span> l <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:       <span class="co"># 判断逻辑 l 不为空  </span>
...     <span class="bu">print</span>(<span class="st">&#39;l is </span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(l))  
... <span class="cf">else</span>:  
...     <span class="bu">print</span>(<span class="st">&#39;l is empty&#39;</span>)  
...   
l <span class="kw">is</span> []  
<span class="op">&gt;&gt;&gt;</span> <span class="cf">if</span> l:   <span class="co"># #3 正确的判断形式  </span>
...     <span class="bu">print</span>(<span class="st">&#39;Do something...&#39;</span>)  
... <span class="cf">else</span>:  
...     <span class="bu">print</span>(<span class="st">&#39;Do other thing...&#39;</span>)  
...   
Do other thing...  
  </code></pre></div>
<p>执行中会调用__nonzero__()来判断自身对象是否为空并返回0/1或True/False，如果没有定义该方法，Python 将调用__len__()进行判断，返回 0 表示为空。如果一个类既没有定义__len__()又没有定义__nonzero__()，该类实例用 if 判断为True。</p>
<h3 id="建议-27连接字符串优先使用-join-而不是">建议 27：连接字符串优先使用 join 而不是 +</h3>
<p>连接字符串使用join将使程序性能更佳，原因是使用每次使用 + 都需要格外分一块内存去存储结果。</p>
<h3 id="建议-28格式化字符串时尽量使用-.format-而不是">建议 28：格式化字符串时尽量使用 .format 而不是 %</h3>
<p><a href="http://blog.csdn.net/handsomekang/article/details/9183303" target="_blank" rel="external">format方法总结</a> 使用 format 格式化字符串有以下好处：</p>
<ul>
<li>format更为灵活，参数顺序和格式不必完全相同<br>
</li>
<li>format更为方便的作为参数传递（例如支持列表的索引操作）<br>
</li>
<li>%最终会被format取代<br>
</li>
<li>%容易抛出异常，而format则不会（未尝是好事）</li>
</ul>
<h3 id="建议-29区别对待可变对象和不可变对象">建议 29：区别对待可变对象和不可变对象</h3>
<p>Python 中一切皆对象，每个对象都有一个唯一的标识符（id）、类型（type）和值。数字、字符串、元组属于不可变对象，字典、列表、字节数组属于可变对象。</p>
<p>默认参数在初始化时仅仅被评估一次，以后直接使用第一次评估的结果，course 指向的是 list 的地址，每次操作的实际上是 list 所指向的具体列表，所以对于可变对象的更改会直接影响原对象。</p>
<p>最好的方法是传入None作为默认参数，在创建对象的时候动态生成列表。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> list1 <span class="op">=</span> [<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>]  
<span class="op">&gt;&gt;&gt;</span> list2 <span class="op">=</span> list1  
<span class="op">&gt;&gt;&gt;</span> list1.append(<span class="st">&#39;d&#39;</span>)  
<span class="op">&gt;&gt;&gt;</span> list2  
[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>]  
<span class="op">&gt;&gt;&gt;</span> list3 <span class="op">=</span> list1[:]  <span class="co"># 可变对象的切片操作相当于浅拷贝  </span>
<span class="op">&gt;&gt;&gt;</span> list3.remove(<span class="st">&#39;a&#39;</span>)  
<span class="op">&gt;&gt;&gt;</span> list3  
[<span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>]  
<span class="op">&gt;&gt;&gt;</span> list1  
[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>]  </code></pre></div>
<h3 id="建议-30-和-一致的容器初始化形式">建议 30：[]、() 和 {} 一致的容器初始化形式</h3>
<p>使用列表解析、字典解析、元组解析等替代for循环<br>
解析式有以下好处：</p>
<ul>
<li>代码更清晰、简洁<br>
</li>
<li>效率更高、速度更快<br>
</li>
<li>（代码更加pythonic）</li>
</ul>
<h3 id="建议-31记住函数传参既不是传值也不是传引用">建议 31：记住函数传参既不是传值也不是传引用</h3>
<p>正确的说法是传对象（call by object）或传对象的引用（call-by-object-reference），函数参数在传递过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，对不可变对象的”修改“往往是通过生成一个新对象然是赋值实现的。</p>
<h3 id="建议-32警惕默认参数潜在的问题">建议 32：警惕默认参数潜在的问题</h3>
<p>其中就是默认参数如果是可变对象，在调用者和被调用者之间是共享的。<br>
所以默认值使用可以使用数字、字符串、元组。<br>
不可以使用字典、列表、字节数组。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> time  
<span class="co"># 对当前系统时间进行处理  </span>
<span class="kw">def</span> report(when<span class="op">=</span>time.time): <span class="co"># 而不是when=time.time()  </span>
    <span class="cf">pass</span>  
  </code></pre></div>
<h3 id="建议-33慎用变长参数">建议 33：慎用变长参数</h3>
<p>原因如下：<br>
1. 使用过于灵活，导致函数签名不够清晰，存在多种调用方式<br>
2. 使用*args和**kw简化函数定义就意味着函数可以有更好的实现方法</p>
<p>使用场景：<br>
1. 为函数添加一个装饰器<br>
2. 参数数目不确定<br>
3. 实现函数的多态或子类需要调用父类的某些方法时</p>
<h3 id="建议-34深入理解-str-和repr-的区别">建议 34：深入理解 str() 和repr() 的区别</h3>
<p>（str方法面向用户更为友好，repr解释更加清晰）<br>
总结几点：</p>
<ol style="list-style-type: decimal">
<li>str()面向用户，返回用户友好和可读性强的字符串类型；repr()面向 Python 解释器或开发人员，返回 Python 解释器内部的含义。<br>
</li>
<li>解释器中输入a默认调用repr()，而print(a)默认调用str()。<br>
</li>
<li>repr()返回值一般可以用eval()还原对象：obj == eval(repr(obj))。<br>
</li>
<li>以上两个方法分别调用内建的__str__()和__repr__()，一般来说类中都应该定义__repr__()，但当可读性比准确性更为重要时应该考虑__str__()，用户实现__repr__()方法的时候最好保证其返回值可以用eval()是对象还原。</li>
</ol>
<h3 id="建议-35分清-staticmethod-和-classmethod-的适用场景">建议 35：分清 staticmethod 和 classmethod 的适用场景</h3>
<p>（需要返回类的实例时，或需要动态生成对应类的类变量，使用classmethod，方法不跟实例与类相关（不适用self和cls），定义为静态方法（工具方法））</p>
<p>调用类方法装饰器的修饰器的方法，会隐式地传入该对象所对应的类，可以动态生成对应的类的类变量，同时如果我们期望根据不同的类型返回对应的类的实例，类方法才是正确的解决方案。</p>
<p>反观静态方法，当我们所定义的方法既不跟特定的实例相关也不跟特定的类相关，可以将其定义为静态方法，这样使我们的代码能够有效地组织起来，提高可维护性。</p>
<p>当然，也可以考虑定义一个模块，将一组的方法放入其中，通过模块来访问。</p>
<h2 id="第-4-章-库">第 4 章 库</h2>
<h3 id="建议-36掌握字符串的基本用法">建议 36：掌握字符串的基本用法</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># 小技巧：Python 遇到未闭合的小括号会自动将多行代码拼接为一行  </span>
<span class="op">&gt;&gt;&gt;</span> s <span class="op">=</span> (<span class="st">&#39;SELECT * &#39;</span>  
...      <span class="st">&#39;FROM table &#39;</span>  
...      <span class="st">&#39;WHERE field=&quot;value&quot;&#39;</span>)  
<span class="op">&gt;&gt;&gt;</span> s  
<span class="co">&#39;SELECT * FROM table WHERE field=&quot;value&quot;&#39;</span>  
<span class="co"># Python2 中使用 basestring 正确判断一个变量是否是字符串  </span>
<span class="co"># 性质判断  </span>
isalnum() isalpha() isdigit() islower() isupper() isspace() istitle()  
<span class="co"># 查找替换  </span>
startswith(prefix[, start[, end]]) endswith(suffix[, start[, end]]) <span class="co"># prefix参数可以接收 tuple 类型的实参  </span>
count(sub[, start[, end]]) find(sub[, start[, end]]) index(sub[, start[, end]])  
rfind(sub[, start[, end]]) rindex(sub[, start[, end]]) replace(old, new[, count])   <span class="co"># count是指的替换次数，不指定就全部替换  </span>
<span class="co"># 切分  </span>
partition(sep) rpartition(sep) splitlines([keepends]) split([sep, [, maxsplit]]) rsplit([sep[, maxsplit]])  <span class="co"># partition 返回一个3个元素的元组对象  </span>
<span class="co"># 变形  </span>
lower() upper() capitalize() swapcase() title()  
<span class="co"># 删减填充  </span>
strip([chars]) lstrip([chars]) rstrip([chars]) <span class="co"># 没有提供chars默认是空白符，由string.whitespace 常量定义  </span>
center(width[, fillchar]) ljuct(width[, fillchar]) rjust(width[, fillchar])  
zfill(width) expandtabs([tabszie])  
  </code></pre></div>
<p>下面来介绍一些易混淆的地方：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="st">&#39;  hello world&#39;</span>.split()  
[<span class="st">&#39;hello&#39;</span>, <span class="st">&#39;world&#39;</span>]  
<span class="op">&gt;&gt;&gt;</span> <span class="st">&#39;  hello world&#39;</span>.split(<span class="st">&#39; &#39;</span>)  
[<span class="st">&#39;&#39;</span>, <span class="st">&#39;&#39;</span>, <span class="st">&#39;hello&#39;</span>, <span class="st">&#39;world&#39;</span>]  
<span class="op">&gt;&gt;&gt;</span> <span class="st">&#39;hello wORld&#39;</span>.title()  
<span class="co">&#39;Hello World&#39;</span>  
<span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> string  
<span class="op">&gt;&gt;&gt;</span> string.capwords(<span class="st">&#39; hello world!&#39;</span>)  
<span class="co">&#39;Hello World!&#39;</span>  
<span class="op">&gt;&gt;&gt;</span> string.whitespace  
<span class="co">&#39; \t\n\r\x0b\x0c&#39;</span>  
  </code></pre></div>
<h3 id="建议-37按需选择-sort-或者-sorted">建议 37：按需选择 sort() 或者 sorted()</h3>
<p>（sort方法是原地操作，sorted是复制操作，不需要保留源列表用sort）</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># 函数原型  </span>
<span class="bu">sorted</span>(iterable[, <span class="bu">cmp</span>[, key[, reverse]]])   <span class="co"># 返回一个排序后的列表  </span>
s.sort([<span class="bu">cmp</span>[, key[, reverse]]])             <span class="co"># 直接修改原列表，返回为None  </span>
<span class="op">&gt;&gt;&gt;</span> persons <span class="op">=</span> [{<span class="st">&#39;name&#39;</span>: <span class="st">&#39;Jon&#39;</span>, <span class="st">&#39;age&#39;</span>: <span class="dv">32</span>}, {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;Alan&#39;</span>, <span class="st">&#39;age&#39;</span>: <span class="dv">50</span>}, {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;Bob&#39;</span>, <span class="st">&#39;age&#39;</span>: <span class="dv">23</span>}]  
<span class="op">&gt;&gt;&gt;</span> <span class="bu">sorted</span>(persons, key<span class="op">=</span><span class="kw">lambda</span> x: (x[<span class="st">&#39;name&#39;</span>], <span class="op">-</span>x[<span class="st">&#39;age&#39;</span>]))  
[{<span class="st">&#39;name&#39;</span>: <span class="st">&#39;Alan&#39;</span>, <span class="st">&#39;age&#39;</span>: <span class="dv">50</span>}, {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;Bob&#39;</span>, <span class="st">&#39;age&#39;</span>: <span class="dv">23</span>}, {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;Jon&#39;</span>, <span class="st">&#39;age&#39;</span>: <span class="dv">32</span>}]  
<span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">3</span>)  
<span class="op">&gt;&gt;&gt;</span> <span class="bu">sorted</span>(a)  
[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]  
  </code></pre></div>
<p>所以如果实际过程中需要保留原有列表，可以使用sorted()。sort()不需要复制原有列表，消耗内存较小，效率较高。同时传入参数key比传入参数cmp效率要高，cmp传入的函数在整个排序过程中会调用多次，而key针对每个元素仅作一次处理。</p>
<h3 id="建议-38使用-copy-模块深拷贝对象">建议 38：使用 copy 模块深拷贝对象</h3>
<p>（对可变对象需要真正意义上的复制时使用copy.deepcopy，这种需求情况还是比较少见）</p>
<ul>
<li><p>浅拷贝（shallow copy）：构造一个新的复合对象并将从原对象中发现的引用插入该对象中。工厂函数、切片操作、copy 模块中的 copy 操作都是浅拷贝</p></li>
<li><p>深拷贝（deep copy）：针对引用所指向的对象继续执行拷贝，因此产生的对象不受其它引用对象操作的影响。深拷贝需要依赖 copy 模块的 deepcopy() 操作</p></li>
</ul>
<p>在 python 中，标识一个对象唯一身份的是：对象的id(内存地址)，对象类型，对象值，而浅拷贝就是创建一个具有相同类型，相同值但不同id的新对象。因此使用浅拷贝的典型使用场景是：对象自身发生改变的同时需要保持对象中的值完全相同，比如 list 排序：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> sorted_list(olist, key<span class="op">=</span><span class="va">None</span>):  
    copied_list <span class="op">=</span> copy.copy(olist)  
    copied_list.sort(key<span class="op">=</span>key)  
    <span class="cf">return</span> copied_list  
a <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]       <span class="co"># [3, 2, 1]  </span>
b <span class="op">=</span> sorted_list(a)  <span class="co"># [1, 2, 3]  </span>
  </code></pre></div>
<p>深拷贝不仅仅拷贝了原始对象自身，也对其包含的值进行拷贝，它会递归的查找对象中包含的其他对象的引用，来完成更深层次拷贝。因此，深拷贝产生的副本可以随意修改而不需要担心会引起原始值的改变：</p>
<pre><code>&gt;&gt;&gt; a = [1, 2]  
&gt;&gt;&gt; b = [a, a]  
&gt;&gt;&gt; b  
[[1, 2], [1, 2]]  
&gt;&gt;&gt; from copy import deepcopy  
&gt;&gt;&gt; c = deepcopy(b)  
&gt;&gt;&gt; id(b[0]) == id(c[0])  
False  
&gt;&gt;&gt; id(b[0]) == id(b[1])  
True  
&gt;&gt;&gt; c  
[[1, 2], [1, 2]]  
&gt;&gt;&gt; c[0].append(3)  
&gt;&gt;&gt; c  
[[1, 2, 3], [1, 2, 3]]  
  </code></pre>
<p>使用 <em>copy</em> 和 <strong>deepcopy</strong> 可以完成对一个对象拷贝的定制。</p>
<p><a href="http://link.zhihu.com/?target=http%3A//wecatch.me/blog/2016/06/18/python-copy-deepcopy/" target="_blank" rel="external">参考博文</a></p>
<h3 id="建议-39-使用-counter-进行计数统计">建议 39： 使用 Counter 进行计数统计</h3>
<p>（需要计数统计时，使用Counter）<br>
常见的计数统计可以使用dict、defaultdict、set和list，不过 Python 提供了一个更优雅的方式：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> collections <span class="im">import</span> Counter  
<span class="op">&gt;&gt;&gt;</span> some_data <span class="op">=</span> {<span class="st">&#39;a&#39;</span>, <span class="st">&#39;2&#39;</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;7&#39;</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;b&#39;</span>}  
<span class="op">&gt;&gt;&gt;</span> Counter(some_data)  
Counter({<span class="st">&#39;7&#39;</span>，: <span class="dv">1</span>, <span class="dv">2</span>: <span class="dv">1</span>, <span class="dv">3</span>: <span class="dv">1</span>, <span class="dv">4</span>: <span class="dv">1</span>, <span class="dv">5</span>: <span class="dv">1</span>, <span class="st">&#39;2&#39;</span>: <span class="dv">1</span>, <span class="st">&#39;b&#39;</span>: <span class="dv">1</span>, <span class="st">&#39;a&#39;</span>: <span class="dv">1</span>, <span class="st">&#39;d&#39;</span>: <span class="dv">1</span>, <span class="st">&#39;c&#39;</span>: <span class="dv">1</span>})  
  </code></pre></div>
<p>Counter 类属于字典类的子类，是一个容器对象，用来统计散列对象，支持+、-、&amp;、|，其中&amp;和|分别返回两个 Counter 对象各元素的最小值和最大值。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># 初始化  </span>
Counter(<span class="st">&#39;success&#39;</span>)  
Counter(s<span class="op">=</span><span class="dv">3</span>, c<span class="op">=</span><span class="dv">2</span>, e<span class="op">=</span><span class="dv">1</span>, u<span class="op">=</span><span class="dv">1</span>)  
Counter({<span class="st">&#39;s&#39;</span>: <span class="dv">3</span>, <span class="st">&#39;c&#39;</span>: <span class="dv">2</span>, <span class="st">&#39;u&#39;</span>: <span class="dv">1</span>, <span class="st">&#39;e&#39;</span>: <span class="dv">1</span>})  
<span class="co"># 常用方法  </span>
<span class="bu">list</span>(Counter(some_data).elements())     <span class="co"># 获取 key 值  </span>
Counter(some_data).most_common(<span class="dv">2</span>)       <span class="co"># 前 N 个出现频率最高的元素以及对应的次数  </span>
(Counter(some_data))[<span class="st">&#39;y&#39;</span>]               <span class="co"># 访问不存在的元素返回 0  </span>
c <span class="op">=</span> Counter(<span class="st">&#39;success&#39;</span>)  
c.update(<span class="st">&#39;successfully&#39;</span>)                <span class="co"># 更新统计值  </span>
c.subtract(<span class="st">&#39;successfully&#39;</span>)              <span class="co"># 统计数相减，允许为0或为负  </span>
  </code></pre></div>
<h3 id="建议-40深入掌握-configparser">建议 40：深入掌握 ConfigParser</h3>
<p>（啥程序都需要配置，要搞懂配置库）<br>
几乎所有的应用程序都会读取配置文件，ini是一种比较常见的文件格式：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">[section1]  
option1<span class="op">=</span><span class="dv">0</span>  </code></pre></div>
<p>Python 提供标准库 ConfigParser 来支持它：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> ConfigParser  
conf <span class="op">=</span> ConfigParser.ConfigParser()  
conf.read(<span class="st">&#39;example.conf&#39;</span>)  
<span class="bu">print</span>(conf.get(<span class="st">&#39;section1&#39;</span>, <span class="st">&#39;in_default&#39;</span>))  
  </code></pre></div>
<p>再来看个SQLAlchemy配置文件的例子：</p>
<pre><code>[DEFAULT]  
conn_str = %(dbn)s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)s  
dbn = mysql  
user = root  
host = localhost  
port = 3306  
[db1]  
user = aaa  
pw = ppp  
db = example  
[db2]  
host = 192.168.0.110  
pw = www  
db = example  
  </code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> ConfigParser  
conf <span class="op">=</span> ConfigParser.ConfigParser()  
conf.read(<span class="st">&#39;format.conf&#39;</span>)  
<span class="bu">print</span>(conf.get(<span class="st">&#39;db1&#39;</span>, <span class="st">&#39;conn_str&#39;</span>))  
<span class="bu">print</span>(conf.get(<span class="st">&#39;db2&#39;</span>, <span class="st">&#39;conn_str&#39;</span>))  </code></pre></div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/19/解决不了问题就崩了心态太不应该/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="王子子">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/large/646083e8jw1e4k8rg9xhdj20ai0am3z6.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="王子子的成长之路">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="王子子的成长之路" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/19/解决不了问题就崩了心态太不应该/" itemprop="url">
                  解决不了问题就崩了心态太不应该
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-19T14:08:01+08:00">
                2017-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于大多数事情来说，失败是常态，无法掌控事情的发展是常态，缺乏安全感的弊端就是恐惧面对这些。问题是越不去面对，挫折固然少了，无法掌控的事情却更多了。要学会坦然面对无法掌控的事情，磨练出更优秀的自己。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ww3.sinaimg.cn/large/646083e8jw1e4k8rg9xhdj20ai0am3z6.jpg"
               alt="王子子" />
          <p class="site-author-name" itemprop="name">王子子</p>
          <p class="site-description motion-element" itemprop="description">天生极客</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/heavysheep/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/wang-zi-zi-81-12/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王子子</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

  


</body>
</html>
