<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="建议 41：使用argparse处理命令行参数
处理命令行参数可以使用argsparse，也推荐更方便更高级的docopt进行处理。
docopt是根据常见的帮助信息定义了一套领域特定语言（DSL），并通过这个DSL Parser参数生成处理命令行参数的代码。
建议 42：使用pandas处理大型CSV文件
pandas作为python三大科学运算库之一的使用。
建议 43：一般情况下使">
<meta property="og:type" content="article">
<meta property="og:title" content="改善 Python 程序的 91 个建议读书笔记 3">
<meta property="og:url" content="http://yoursite.com/2017/06/08/改善 Python 程序的 91 个建议读书笔记 3/index.html">
<meta property="og:site_name" content="王子子的成长之路">
<meta property="og:description" content="建议 41：使用argparse处理命令行参数
处理命令行参数可以使用argsparse，也推荐更方便更高级的docopt进行处理。
docopt是根据常见的帮助信息定义了一套领域特定语言（DSL），并通过这个DSL Parser参数生成处理命令行参数的代码。
建议 42：使用pandas处理大型CSV文件
pandas作为python三大科学运算库之一的使用。
建议 43：一般情况下使">
<meta property="og:updated_time" content="2017-06-29T07:27:01.556Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="改善 Python 程序的 91 个建议读书笔记 3">
<meta name="twitter:description" content="建议 41：使用argparse处理命令行参数
处理命令行参数可以使用argsparse，也推荐更方便更高级的docopt进行处理。
docopt是根据常见的帮助信息定义了一套领域特定语言（DSL），并通过这个DSL Parser参数生成处理命令行参数的代码。
建议 42：使用pandas处理大型CSV文件
pandas作为python三大科学运算库之一的使用。
建议 43：一般情况下使">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/08/改善 Python 程序的 91 个建议读书笔记 3/"/>





  <title> 改善 Python 程序的 91 个建议读书笔记 3 | 王子子的成长之路 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">王子子的成长之路</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">王子子</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-course">
          <a href="/categories/历程" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-blind"></i> <br />
            
            历程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-study">
          <a href="/categories/学习" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-plug"></i> <br />
            
            学习
          </a>
        </li>
      
        
        <li class="menu-item menu-item-essay">
          <a href="/categories/随笔" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-optin-monster"></i> <br />
            
            随笔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/08/改善 Python 程序的 91 个建议读书笔记 3/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="王子子">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/large/646083e8jw1e4k8rg9xhdj20ai0am3z6.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="王子子的成长之路">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="王子子的成长之路" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                改善 Python 程序的 91 个建议读书笔记 3
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-08T22:54:00+08:00">
                2017-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="建议-41使用argparse处理命令行参数">建议 41：使用argparse处理命令行参数</h3>
<p>处理命令行参数可以使用argsparse，也推荐更方便更高级的docopt进行处理。<br>
docopt是根据常见的帮助信息定义了一套领域特定语言（DSL），并通过这个DSL Parser参数生成处理命令行参数的代码。</p>
<h3 id="建议-42使用pandas处理大型csv文件">建议 42：使用pandas处理大型CSV文件</h3>
<p>pandas作为python三大科学运算库之一的使用。</p>
<h3 id="建议-43一般情况下使用elementtree解析xml格式文件">建议 43：一般情况下使用ElementTree解析xml格式文件</h3>
<p>使用Beautifulsoup更好</p>
<h3 id="建议-44理解模块pickle优劣">建议 44：理解模块pickle优劣</h3>
<p>序列化，简单来说就是把内存中的数据结构在不丢失其身份和类型信息的情况下转成对象的文本或二进制表示的过程。同类支持序列化的模块有pickle，json，marshal和shelve。</p>
<p>pickle是最通用的序列化模块，我们应该优先使用c语言实现的<strong>cPickle</strong>，速度比pickle快1000倍，区别是cPickle不能被继承。</p>
<p>pickle主要通过dump和load两种方法序列化与反序列化（存储与读取）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle  </div><div class="line"><span class="comment"># 序列化  </span></div><div class="line">my_data= &#123;<span class="string">"name"</span>:<span class="string">"Python"</span>,<span class="string">"type"</span>:<span class="string">"Language"</span>&#125;  </div><div class="line">fp = open(<span class="string">"picklefile.dat"</span>,<span class="string">"wb"</span>)  </div><div class="line">pickle.dump(my_data, fp)  </div><div class="line">fp.close  </div><div class="line">  </div><div class="line"><span class="comment"># 反序列化  </span></div><div class="line">fp = open(<span class="string">"picklefile.dat"</span>, <span class="string">"rb"</span>)  </div><div class="line">out = pickle.load(fp)  </div><div class="line">```  </div><div class="line">pickle模块的优点：  </div><div class="line"><span class="number">1.</span> 接口简单，容易使用。  </div><div class="line"><span class="number">2.</span> 存储格式有平台通用型，在Linux和Windouws都可以使用，兼容性好。  </div><div class="line"><span class="number">3.</span> 支持数据类型广泛，除了常规项，还包含能通过类的\__dict__或\__getstate__()方法返回的对象。  </div><div class="line"><span class="number">4.</span> pickle是可扩展的，对于不可序列化的对象，也可以通过特殊方法来返回示例在被pickle时的状态。  </div><div class="line"><span class="number">5.</span> 能够自动维护对象间的引用  </div><div class="line">  </div><div class="line">pickle模块的限制：  </div><div class="line">* pickle不能保证操作的原子性。当错误发生时，可能部分数据已经被保存；如果对象处于深递归状态，那么可能超过python的最大递归深度，可以通过sys.setrecursionlimit()进行扩展。  </div><div class="line">* pickle存在安全性问题，为乳清提供了可能。  </div><div class="line">* pickle协议是python特定的，不同语言之间数据内容可能难以保障。  </div><div class="line">  </div><div class="line">简单来说，对于需要存储的对象，使用pickle，另外很重要的一点，**dat文件用pickle模块来读**。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 45：序列化的另一个不错的选择 -- JSON  </span></div><div class="line">cJson比python自身的json要快<span class="number">250</span>倍  </div><div class="line">JSON的优势：  </div><div class="line"><span class="number">1.</span> 使用简单，支持多种数据类型（集合、列表、字典、关联数组等等）  </div><div class="line"><span class="number">2.</span> 存储格式可读性更友好，易于修改  </div><div class="line"><span class="number">3.</span> 支持跨平台跨语言操作，所占空间更小  </div><div class="line"><span class="number">4.</span> 具有较强扩展性  </div><div class="line">  </div><div class="line">json的速度比pickle略慢。  </div><div class="line">**json不支持序列化dateime**  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 46：使用 traceback 获取栈信息  </span></div><div class="line">  </div><div class="line">当发生异常，开发人员往往需要看到现场信息，trackback 模块可以满足这个需求，先列几个常用的：  </div><div class="line">  </div><div class="line">```python  </div><div class="line">traceback.print_exc()   <span class="comment"># 打印错误类型、值和具体的trace信息  </span></div><div class="line">traceback.print_exception(type, value, traceback[, limit[, file]])  <span class="comment"># 前三个参数的值可以从sys.exc_info()  </span></div><div class="line">raceback.print_exc([limit[, file]])         <span class="comment"># 同上，不需要传入那么多参数  </span></div><div class="line">traceback.format_exc([limit])               <span class="comment"># 同 print_exc()，返回的是字符串  </span></div><div class="line">traceback.extract_stack([file, [, limit]])  <span class="comment"># 从当前栈中提取 trace 信息  </span></div><div class="line">```  </div><div class="line">  </div><div class="line">traceback 模块获取异常相关的数据是通过sys.exc_info()得到的，该函数返回异常类型type、异常value、调用和堆栈信息traceback组成的元组。  </div><div class="line">  </div><div class="line">同时 inspect 模块也提供了获取 traceback 对象的接口。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 47：使用 logging 记录日志信息  </span></div><div class="line">  </div><div class="line">仅仅将信息输出到控制台是远远不够的，更为常见的是使用日志保存程序运行过程中的相关信息，如运行时间、描述信息以及错误或者异常发生时候的特定上下文信息。Python 提供 logging 模块提供了日志功能。  </div><div class="line">  </div><div class="line">常规日志设置:  </div><div class="line">```python  </div><div class="line">logging.basicConfig(  </div><div class="line">            filename=<span class="string">'%s.log'</span> % self.table_name,  </div><div class="line">            level=logging.DEBUG,  </div><div class="line">            format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,  </div><div class="line">            datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>)  </div><div class="line">```  </div><div class="line">logging是线程安全的，不支持多进程写入同一个子文件，对多个进程需要配置不同的日志文件。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 48：使用 threading 模块编写多线程程序  </span></div><div class="line">（python3中，使用threadpool线程池模块比较省心）  </div><div class="line">由于 GIL 的存在，让 Python 多线程编程在多核处理器中无法发挥优势，但在一些使用场景下使用多线程仍然比较好，如等待外部资源返回，或建立反应灵活的用户界面，或多用户程序等。  </div><div class="line">  </div><div class="line">Python3 提供了两个模块：_thread和threading。_thread提供了底层的多线程支持，使用比较复杂，下面我们重点说说threading。  </div><div class="line">  </div><div class="line">Python 多线程支持用两种方式来创建线程：一种通过继承 Thread 类，重写它的run()方法；另一种是创建一个 threading.Thread 对象，在它的初始化函数__init__()中将可调用对象作为参数传入。  </div><div class="line">  </div><div class="line">threading模块中不仅有 Lock 指令锁，RLock 可重入指令锁，还支持条件变量 Condition、信号量 Semaphore、BoundedSemaphore 以及 Event 事件等。  </div><div class="line">  </div><div class="line">下面有一个比较经典的例子来理解多线程：</div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="keyword">import</span> threading  </div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime,sleep  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">music</span><span class="params">(func)</span>:</span>  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </div><div class="line">        print(<span class="string">"I was listening to %s. %s"</span> % (func,ctime()))  </div><div class="line">        sleep(<span class="number">1</span>)    <span class="comment"># 程序休眠 1 秒  </span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(func)</span>:</span>  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </div><div class="line">        print(<span class="string">"I was at the %s! %s"</span> % (func,ctime()))  </div><div class="line">        sleep(<span class="number">5</span>)  </div><div class="line">  </div><div class="line">threads = []  </div><div class="line">t1 = threading.Thread(target=music,args=(<span class="string">'爱情买卖'</span>,))  </div><div class="line">threads.append(t1)  </div><div class="line">t2 = threading.Thread(target=move,args=(<span class="string">'阿凡达'</span>,))  </div><div class="line">threads.append(t2)  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:  </div><div class="line">        t.setDaemon(<span class="keyword">True</span>)   <span class="comment"># 声明线程为守护线程  </span></div><div class="line">        t.start()  </div><div class="line">    <span class="comment">#3  </span></div><div class="line">    print(<span class="string">"all over %s"</span> % ctime())  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line">以下是运行结果：  </div><div class="line">  </div><div class="line">```python  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">02</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">02</span> <span class="number">2017</span>  </div><div class="line">all over Tue Apr  <span class="number">4</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">02</span> <span class="number">2017</span>  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line">分析：threading 模块支持线程守护，我们可以通过setDaemon()来设置线程的daemon属性，当其属性为<span class="keyword">True</span>时，表明主线程的退出可以不用等待子线程完成，反之，daemon属性为<span class="keyword">False</span>时所有的非守护线程结束后主线程才会结束，那运行结果为：  </div><div class="line">  </div><div class="line">```python  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">26</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">26</span> <span class="number">2017</span>  </div><div class="line">all over Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">26</span> <span class="number">2017</span>  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">27</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">31</span> <span class="number">2017</span>  </div><div class="line">  </div><div class="line">```  </div><div class="line"></div><div class="line">继续修改代码，当我们在<span class="comment">#3处加入t.join()，此方法能够阻塞当前上下文环境，直到调用该方法的线程终止或到达指定的 timeout，此时在运行程序：  </span></div><div class="line">  </div><div class="line">```python  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">15</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">15</span> <span class="number">2017</span>  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">16</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">20</span> <span class="number">2017</span>  </div><div class="line">all over Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">08</span>:<span class="number">25</span> <span class="number">2017</span>  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line">当我们把music函数的休眠时间改为 <span class="number">4</span> 秒，再次运行程序：  </div><div class="line">  </div><div class="line">```python</div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">16</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">16</span> <span class="number">2017</span>  </div><div class="line">I was listening to 爱情买卖. Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">20</span> <span class="number">2017</span>  </div><div class="line">I was at the 阿凡达! Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">21</span> <span class="number">2017</span>  </div><div class="line">all over Tue Apr  <span class="number">4</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">26</span> <span class="number">2017</span>  </div><div class="line">```  </div><div class="line">此时我们就可以发现多线程的威力了，music虽然增加了 <span class="number">3</span> 秒，然而总的运行时间仍然为 <span class="number">10</span> 秒。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 49：使用 Queue 使多线程编程更加安全  </span></div><div class="line">（同<span class="number">47</span>，使用threadingpool）  </div><div class="line">线程间的同步和互斥，线程间数据的共享等这些都是涉及线程安全要考虑的问题。纵然 Python 中提供了众多的同步和互斥机制，如 mutex、condition、event 等，但同步和互斥本身就不是一个容易的话题，稍有不慎就会陷入死锁状态或者威胁线程安全。  </div><div class="line">  </div><div class="line">如何保证线程安全呢？我们先来看看 Python 中的 Queue 模块：  </div><div class="line">  </div><div class="line">* Queue.Queue(maxsize)：先进先出，maxsize 为队列大小，其值为非正数的时候为无限循环队列  </div><div class="line">* Queue.LifoQueue(maxsize)：后进先出，相当于栈  </div><div class="line">* Queue.PriorityQueue(maxsize)：优先级队列  </div><div class="line">  </div><div class="line">以上队列所支持的方法：  </div><div class="line">  </div><div class="line">* Queue.qsize()：返回近似的队列大小。当该值 &gt; <span class="number">0</span> 的时候并不保证并发执行的时候 get() 方法不被阻塞，同样，对于 put() 方法有效。  </div><div class="line">* Queue.empty()：队列为空的时候返回 <span class="keyword">True</span>，否则返回 <span class="keyword">False</span>  </div><div class="line">* Queue.full()：当设定了队列大小的情况下，如果队列满则返回 <span class="keyword">True</span>，否则返回 <span class="keyword">False</span>  </div><div class="line">* Queue.put(item[, block[, timeout]])：往队列中添加元素 item，block 设置为 <span class="keyword">False</span> 的时候，如果队列满则抛出 Full 异常。如果 block 设置为 <span class="keyword">True</span>，timeout 为 <span class="keyword">None</span> 的时候则会一直等待直到有空位置，否则会根据 timeout 的设定超时后抛出 Full 异常  </div><div class="line">* Queue.put_nowait(item)：等于 put(item, <span class="keyword">False</span>).block 设置为 <span class="keyword">False</span> 的时候，如果队列空则抛出 Empty 异常。如果 block 设置为 <span class="keyword">True</span>、timeout 为 <span class="keyword">None</span> 的时候则会一直等到有元素可用，否则会根据 timeout 的设定超时后抛出 Empty 异常  </div><div class="line">* Queue.get([block[, timeout]])：从队列中删除元素并返回该元素的值  </div><div class="line">* Queue.get_nowait()：等价于 get(<span class="keyword">False</span>)  </div><div class="line">* Queue.task_done()：发送信号表明入列任务已经完成，经常在消费者线程中用到  </div><div class="line">* Queue.join()：阻塞直至队列中所有的元素处理完毕  </div><div class="line">首先 Queue 中的队列和 collections.deque 所表示的队列并不一样，前者用于不同线程之间的通信，内部实现了线程的锁机制，后者是数据结构上的概念，支持 <span class="keyword">in</span> 方法。  </div><div class="line">  </div><div class="line">Queue 模块实现了多个生产者多个消费者的队列，当多线程之间需要信息安全的交换的时候特别有用，因此这个模块实现了所需要的锁原语，为 Python 多线程编程提供了有力的支持，它是线程安全的。  </div><div class="line">  </div><div class="line">先来看一个简单的例子：  </div><div class="line">```python  </div><div class="line"><span class="keyword">import</span> os  </div><div class="line"><span class="keyword">import</span> Queue  </div><div class="line"><span class="keyword">import</span> threading  </div><div class="line"><span class="keyword">import</span> urllib2  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span><span class="params">(threading.Thead)</span>:</span>  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span>  </div><div class="line">        threading.Thread.__init__(self)  </div><div class="line">        self.queue = queue  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:  </div><div class="line">            url = self.queue.get()  </div><div class="line">            print(<span class="string">'&#123;0&#125; begin download &#123;1&#125;...'</span>.format(self.name, url))  </div><div class="line">            self.download_file(url)  </div><div class="line">            self.queque.task_done()  </div><div class="line">            print(<span class="string">'&#123;0&#125; download completed!!!'</span>.format(self.name))  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download_file</span><span class="params">(self, url)</span>:</span>  </div><div class="line">        urlhandler = urllib2.urlopen(url)  </div><div class="line">        fname = os.path.basename(url) + <span class="string">'.html'</span>  </div><div class="line">        <span class="keyword">with</span> open(fname, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  </div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:  </div><div class="line">                chunk = urlhandler.read(<span class="number">1024</span>)  </div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> chunk: <span class="keyword">break</span>  </div><div class="line">                f.write(chunk)  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </div><div class="line">    urls = [<span class="string">'http://wiki.python.org/moin/WebProgramming'</span>,  </div><div class="line">            <span class="string">'https://www.createspace.com/3611970'</span>,  </div><div class="line">            <span class="string">'http://wiki.python.org/moin/Documentation'</span>  </div><div class="line">    ]  </div><div class="line">    queue = Queue.Queue()  </div><div class="line">    <span class="keyword">for</span> i range(<span class="number">5</span>):  </div><div class="line">        t = DownloadThread(queue)  </div><div class="line">        t.setDaemon(<span class="keyword">True</span>)  </div><div class="line">        t.start()  </div><div class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:  </div><div class="line">        queue.put(url)  </div><div class="line">    queue.join()  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line"><span class="comment">## 第 5 章 设计模式  </span></div><div class="line"><span class="comment">### 建议 50：利用模块实现单例模式  </span></div><div class="line">单例模式可以保证徐彤中一个类只有一个实例且该实例易被外界访问，常用来使用XxxManager之类的功能。  </div><div class="line">  </div><div class="line">满足单例模式的 <span class="number">3</span> 个需求：  </div><div class="line">  </div><div class="line">* 只能有一个实例  </div><div class="line">* 必须自行创建这个实例  </div><div class="line">* 必须自行向整个系统提供这个实例  </div><div class="line">  </div><div class="line">模块采用的其实是天然的单例的实现方式，在入口文件导入：  </div><div class="line">* 所有的变量都会绑定到模块  </div><div class="line">* 模块只初始化一次  </div><div class="line">* <span class="keyword">import</span> 机制是线程安全的，保证了在并发状态下模块也只是一个实例  </div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="comment"># World.py  </span></div><div class="line"><span class="keyword">import</span> Sun  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span>  </div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  </div><div class="line">        Sun.rise()  </div><div class="line">        Sun.set()  </div><div class="line">  </div><div class="line"><span class="comment"># main.py  </span></div><div class="line"><span class="keyword">import</span> World  </div><div class="line">World.run()  </div><div class="line">```  </div><div class="line">  </div><div class="line">此外，Borg模式可以创造任意数量实例，并保证状态共享。  </div><div class="line">  </div><div class="line"><span class="comment">### 建议 51：用 mixin 模式让程序更加灵活  </span></div><div class="line">模板方法模式就是在一个方法中定义一个算法的骨架，并将一些实现步骤延迟到子类中。模板方法可以使子类在不改变算法结构的情况下，重新定义算法中的某些步骤。  </div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseSimpleTeapot</span><span class="params">(object)</span>:</span>  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_teapot</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">return</span> SimpleTeapot()  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseKungfuTeapot</span><span class="params">(object)</span>:</span>  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_teapot</span><span class="params">(self)</span>:</span>  </div><div class="line">        <span class="keyword">return</span> KungfuTeapot()  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficePeople</span><span class="params">(People, UseSimpleTeapot)</span>:</span> <span class="keyword">pass</span>  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePeople</span><span class="params">(People, UseSimpleTeapot)</span>:</span> <span class="keyword">pass</span>  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span><span class="params">(People, UseKungfuTeapot)</span>:</span> <span class="keyword">pass</span>  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_tea_people</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    people.__base__ += (UseSimpleTeapot,)  </div><div class="line">    <span class="keyword">return</span> people  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">coffee_people</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    people.__base__ += (UseCoffeepot,)  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tea_and_coffee_people</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    people.__base__ += (UseSimpleTeapot, UserCoffeepot,)  </div><div class="line">    <span class="keyword">return</span> people  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">boss</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    people.__base__ += (KungfuTeapot, UseCoffeepot, )  </div><div class="line">    <span class="keyword">return</span> people  </div><div class="line">  </div><div class="line">```  </div><div class="line">  </div><div class="line">代码的原理在于每个类都有一个__bases__属性，它是一个元组，用来存放所有的基类，作为动态语言，Python 中的基类可以在运行中可以动态改变。所以当我们向其中增加新的基类时，这个类就拥有了新的方法，这就是混入mixin。  </div><div class="line">  </div><div class="line">利用这个技术我们可以在不修改代码的情况下就可以完成需求：  </div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="keyword">import</span> mixins   <span class="comment"># 把员工需求定义在 Mixin 中放在 mixins 模块  </span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">staff</span><span class="params">()</span>:</span>  </div><div class="line">    people = People()  </div><div class="line">    bases = []  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> config.checked():  </div><div class="line">        bases.append(getattr(maxins, i))  </div><div class="line">    people.__base__ += tuple(bases)  </div><div class="line">    <span class="keyword">return</span> people  </div><div class="line">  </div><div class="line">```  </div><div class="line"></div><div class="line"><span class="comment">### 建议 52：用发布订阅模式实现松耦合  </span></div><div class="line">  </div><div class="line">发布订阅模式是一种编程模式，消息的发送者不会发送其消息给特定的接收者，而是将发布的消息分为不同的类别直接发布，并不关注订阅者是谁。而订阅者可以对一个或多个类别感兴趣，且只接收感兴趣的消息，并且不关注是哪个发布者发布的消息。要实现这个模式，就需要一个中间代理人。   Broker，它维护着发布者和订阅者的关系，订阅者把感兴趣的主题告诉它，而发布者的信息也通过它路由到各个订阅者处。  </div><div class="line">  </div><div class="line">```python  </div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  </div><div class="line">route_table = defaultdict(list)  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(topic, callback)</span>:</span>  </div><div class="line">    <span class="keyword">if</span> callback <span class="keyword">in</span> route_table[topic]:  </div><div class="line">        <span class="keyword">return</span>  </div><div class="line">    route_table[topic].append(callback)  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pub</span><span class="params">(topic, *args, **kw)</span>:</span>  </div><div class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> route_table[topic]:  </div><div class="line">        func(*args, **kw)  </div><div class="line">  </div><div class="line">```  </div><div class="line">将以上代码放在 Broker.py 的模块，省去了各种参数检测、优先处理、取消订阅的需求，只向我们展示发布订阅模式的基础实现：  </div><div class="line">  </div><div class="line">```python</div><div class="line"><span class="keyword">import</span> Broker</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'Hello, &#123;&#125;'</span>.format(name))  </div><div class="line">Broker.sub(<span class="string">'greet'</span>, greeting)</div><div class="line">Broker.pub(<span class="string">'greet'</span>, <span class="string">'LaiYonghao'</span>)</div></pre></td></tr></table></figure>
<p>因为python-message的消息订阅默认是全局性的，所以有可能产生名字冲突。</p>
<h3 id="建议-53用状态模式美化代码">建议 53：用状态模式美化代码</h3>
<p>所谓状态模式，就是当一个对象的内在状态改变时允许改变其行为，但这个对象看起来像是改变了其类。</p>
<p>简单的状态模式有其缺点：</p>
<ul>
<li>查询对象的当前状态很麻烦<br>
</li>
<li>状态切换时需要对原状态做一些清扫工作，而对新状态做初始化工作，因每个状态需要做的事情不同，全部写在切换状态的代码中必然重复</li>
</ul>
<p>这时候我们可以使用 Python-state 来解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> state <span class="keyword">import</span> curr, switch, stateful, State, behavior</div><div class="line"><span class="meta">@stateful</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Workday</span><span class="params">(State)</span>:</span></div><div class="line">        default = <span class="keyword">True</span></div><div class="line"><span class="meta">        @behavior   # 相当于staticmethod</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(self)</span>:</span>  <span class="comment"># 这里的self并不是Python的关键字，而是有助于我们理解状态类的宿主是People的实例</span></div><div class="line">            print(<span class="string">'work hard'</span>)</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Weekend</span><span class="params">(State)</span>:</span></div><div class="line"><span class="meta">        @behavior</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(self)</span>:</span></div><div class="line">            print(<span class="string">'play harder'</span>)</div><div class="line">people = People()</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>):</div><div class="line">        <span class="keyword">if</span> i == <span class="number">6</span>:</div><div class="line">            switch(people, People.Weekend)</div><div class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</div><div class="line">            switch(people, People.Workday)</div><div class="line">        people.day()</div></pre></td></tr></table></figure>
<p><span class="citation">@statefule装饰器重载了被修饰的类的__getattr__</span>()从而使得 People 的实例能够调用当前状态类的方法，同时被修饰的类的实例是带有状态的，能够使用curr()查询当前状态，也可以使用switch()进行状态切换，默认的状态是通过类定义的 default 属性标识，default = True的类成为默认状态。</p>
<p>状态类 Workday 和 Weekend 继承自 State 类，从其派生的子类可以使用__begin__和__end___状态转换协议，自定义进入和离开当前状态时对宿主的初始化和清理工作。</p>
<p>下面是一个真实业务的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@stateful</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NeedSignin</span><span class="params">(State)</span>:</span></div><div class="line">        default = <span class="keyword">True</span></div><div class="line"><span class="meta">        @behavior</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">signin</span><span class="params">(self, user, pwd)</span>:</span></div><div class="line">            ...</div><div class="line">            switch(self, Player.Signin)</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Signin</span><span class="params">(State)</span>:</span></div><div class="line"><span class="meta">        @behavior</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, dst)</span>:</span> ...</div><div class="line"><span class="meta">        @behavior</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">atk</span><span class="params">(self, other)</span>:</span> ...</div></pre></td></tr></table></figure>
<h2 id="第-6-章-内部机制">第 6 章 内部机制</h2>
<h3 id="建议-54理解-built-in-objects">建议 54：理解 built-in objects</h3>
<p>Python 中一切皆对象，在新式类中，object 是所有内建类型的基类，用户自定义的类可以继承自 object 也可继承自内建类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">TestNewClass</span>:</span></div><div class="line">   ...:     __metaclass__ = type</div><div class="line">   ...:     </div><div class="line"></div><div class="line">In [<span class="number">2</span>]: type(TestNewClass)</div><div class="line">Out[<span class="number">2</span>]: type</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: TestNewClass.__bases__</div><div class="line">Out[<span class="number">3</span>]: (object,)</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: a = TestNewClass()</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: type(a)</div><div class="line">Out[<span class="number">5</span>]: __main__.TestNewClass</div><div class="line"></div><div class="line">In [<span class="number">6</span>]: a.__class__</div><div class="line">Out[<span class="number">6</span>]: __main__.TestNewClass</div></pre></td></tr></table></figure>
<p>新式类支持 property 和描述符特性，作为新式类的祖先，Object 类还定义了一些特殊方法：<strong>new</strong>()、<strong>init</strong>()、<strong>delattr</strong>()、<strong>getattribute</strong>()、<strong>setattr</strong>()、<strong>hash</strong>()、<strong>repr</strong>()、<strong>str</strong>()等。</p>
<h3 id="建议-55init不是构造方法">建议 55：<strong>init</strong>()不是构造方法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></div><div class="line">        print(cls)</div><div class="line">        print(args)</div><div class="line">        print(kw)</div><div class="line">        print(<span class="string">'----------'</span>)</div><div class="line">        instance = object.__new__(cls, *args, **kw)</div><div class="line">        print(instance)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></div><div class="line">        print(<span class="string">'init gets called'</span>)</div><div class="line">        print(<span class="string">'self is &#123;&#125;'</span>.format(self))</div><div class="line">        self.a, self.b = a, b</div><div class="line">a1 = A(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">print(a1.a)</div><div class="line">print(a1.b)</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;class '__main__.A'&gt;</div><div class="line">(1, 2)</div><div class="line">&#123;&#125;</div><div class="line">----------</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "test.py", line 19, in &lt;module&gt;</div><div class="line">    a1 = A(1, 2)</div><div class="line">  File "test.py", line 13, in __new__</div><div class="line">    instance = object.__new__(cls, *args, **kw)</div><div class="line">TypeError: object() takes no parameters</div></pre></td></tr></table></figure>
<p>从结果中我们可以看出，程序输出了__new__()调用所产生的输出，并抛出了异常。于是我们知道，原来__new__()才是真正创建实例，是类的构造方法，而__init__()是在类的对象创建好之后进行变量的初始化。上面程序抛出异常是因为在__new__()中没有显式返回对象，a1此时为None，当去访问实例属性时就抛出了异常。</p>
<p>根据官方文档，我们可以总结以下几点：</p>
<ul>
<li>object.<strong>new</strong>(cls[, args…])：其中 cls 代表类，args 为参数列表，为静态方法<br>
</li>
<li>object.<strong>init</strong>(self[, args…])：其中 self 代表实例对象，args 为参数列表，为实例方法<br>
</li>
<li>控制实例创建的时候可使用 <strong>new</strong>() ，而控制实例初始化的时候使用 <strong>init</strong>()</li>
<li><strong>new</strong>()需要返回类的对象，当返回类的对象时将会自动调用__init__()进行初始化，没有对象返回，则__init__()不会被调用。<strong>init</strong>() 方法不需要显示返回，默认为 None，否则会在运行时抛出 TypeError<br>
</li>
<li>但当子类继承自不可变类型，如 str、int、unicode 或者 tuple 的时候，往往需要覆盖__new__()<br>
</li>
<li>覆盖 <strong>new</strong>() 和 <strong>init</strong>() 的时候这两个方法的参数必须保持一致，如果不一致将导致异常<br>
下面我们来总结需要覆盖__new__()的几种特殊情况：<br>
</li>
<li>当类继承不可变类型且默认的 <strong>new</strong>() 方法不能满足需求的时候<br>
</li>
<li>用来实现工厂模式或者单例模式或者进行元类编程，使用__new__()来控制对象创建<br>
</li>
<li>作为用来初始化的 <strong>init</strong>() 方法在多继承的情况下，子类的 <strong>init</strong>()方法如果不显式调用父类的 <strong>init</strong>() 方法，则父类的 <strong>init</strong>() 方法不会被调用；通过super(子类， self).<strong>init</strong>()显式调用父类的初始化方法；对于多继承的情况，我们可以通过迭代子类的 <strong>bases</strong> 属性中的内容来逐一调用父类的初始化方法</li>
</ul>
<p>分别来看例子加深理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个集合能够将任何以空格隔开的字符串变为集合中的元素</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSet</span><span class="params">(frozenset)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args)</span>:</span></div><div class="line">        <span class="keyword">if</span> args <span class="keyword">and</span> isinstance(args[<span class="number">0</span>], str):</div><div class="line">            args = (args[<span class="number">0</span>].split(), ) + args[<span class="number">1</span>:]</div><div class="line">        <span class="keyword">return</span> super(UserSet, cls).__new__(cls, *args)</div><div class="line"></div><div class="line"><span class="comment"># 一个工厂类根据传入的参量决定创建出哪一种产品类的实例</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span><span class="params">(Shape)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am a triangle"</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am drawing triangle"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(Shape)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am a rectangle"</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am drawing triangle"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trapezoid</span><span class="params">(Shape)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am a trapezoid"</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am drawing triangle"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Diamond</span><span class="params">(Shape)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am a diamond"</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I am drawing triangle"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span><span class="params">(object)</span>:</span></div><div class="line">    shapes = &#123;<span class="string">'triangle'</span>: Triangle, <span class="string">'rectangle'</span>: Rectangle, <span class="string">'trapzoid'</span>: Trapezoid, <span class="string">'diamond'</span>: Diamond&#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name)</span>:</span></div><div class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> ShapeFactory.shapes.keys():</div><div class="line">            print(<span class="string">'creating a new shape &#123;&#125;'</span>.format(name))</div><div class="line">            <span class="keyword">return</span> ShapeFactory.shapes[name]()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'creating a new shape &#123;&#125;'</span>.format(name))</div><div class="line">            <span class="keyword">return</span> Shape()</div></pre></td></tr></table></figure>
<h3 id="建议-56理解名字查找机制">建议 56：理解名字查找机制</h3>
<p>在 Python 中所谓的变量其实都是名字，这些名字指向一个或多个 Python 对象。这些名字都存在于一个表中（命名空间），我们称之为局部变量，调用locals()可以查看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; locals()</div><div class="line">&#123;'__package__': None, '__spec__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__doc__': None, '__name__': '__main__', '__builtins__': &lt;module 'builtins' (built-in)&gt;&#125;</div><div class="line">&gt;&gt;&gt; globals()</div><div class="line">&#123;'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__package__': None, '__doc__': None, '__spec__': None, '__name__': '__main__'&#125;</div></pre></td></tr></table></figure>
<p>Python 中的作用域分为：</p>
<ul>
<li>局部作用域: 一般来说函数的每次调用都会创建一个新的本地作用域, 拥有新的命名空间<br>
</li>
<li>全局作用域: 定义在 Python 模块文件中的变量名拥有全局作用域, 即在一个文件的顶层的变量名仅在这个文件内可见<br>
</li>
<li>嵌套作用域: 多重函数嵌套时才会考虑, 即使使用 global 进行申明也不能达到目的, 其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量<br>
</li>
<li>内置作用域: 通过标准库中的__builtin__实现的 当访问一个变量的时候，其查找顺序遵循变量解析机制 LEGB 法则，即依次搜索 4 个作用域：局部作用域、嵌套作用域、全局作用域以及内置作用域，并在第一个找到的地方停止搜寻，如果没有搜到，则会抛出异常。</li>
</ul>
<p>Python 3 中引入了 nonlocal 关键字:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></div><div class="line">    a = x</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> a</div><div class="line">        b = a * <span class="number">2</span></div><div class="line">        a = b + <span class="number">1</span></div><div class="line">        print(a)</div><div class="line">    <span class="keyword">return</span> bar</div></pre></td></tr></table></figure>
<h3 id="建议-57-为什么需要-self-参数">建议 57: 为什么需要 self 参数</h3>
<p>在类中当定义实例方法的时候需要将第一个参数显式声明为self, 而调用时不需要传入该参数, 我们通过self.x访问实例变量, self.m()访问实例方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfTest</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self.name)</span>:</span></div><div class="line">        self.name = name</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showself</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'self here is &#123;&#125;'</span>.format(self))</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></div><div class="line">        self.showself()</div><div class="line">        print(<span class="string">'The name is: &#123;&#125;'</span>.format(self.name))</div><div class="line">st = SelfTest(<span class="string">'instance self'</span>)</div><div class="line">st.display()</div><div class="line">print(<span class="string">'&#123;&#125;'</span>.format(st))</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self here <span class="keyword">is</span> &lt;__main__.SelfTest object at <span class="number">0x7f440c53ba58</span>&gt;</div><div class="line">The name <span class="keyword">is</span>: instance self</div><div class="line">&lt;__main__.SelfTest object at <span class="number">0x7f440c53ba58</span>&gt;</div></pre></td></tr></table></figure>
<p>从中可以发现, self 表示实例对象本身, 即 SelfTest 类的对象在内存中的地址. self 是对对象 st 本身的引用, 我们在调用实例方法时也可以直接传入实例对象: SelfTest.display(st). 同时 self 或 cls 并不是 Python 的关键字, 可以替换成其它的名称。</p>
<p>Python 中为什么需要 self 呢:</p>
<ol style="list-style-type: decimal">
<li>借鉴了其他语言的特征</li>
<li>Python 语言本身的动态性决定了使用 self 能够带来一定便利<br>
</li>
<li>在存在同名的局部变量以及实例变量的情况下使用 self 使得实例变量更容易被区分</li>
</ol>
<p>Python 属于一级对象语言, 我们有好几种方法可以引用类方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A.__dict__[<span class="string">"m"</span>]</div><div class="line">A.m.__func__</div></pre></td></tr></table></figure>
<p>Python 的哲学是：显示优于隐式（Explicit is better than implicit）。</p>
<h3 id="建议-58-理解-mro-与多继承">建议 58: 理解 MRO 与多继承</h3>
<p>古典类与新式类所采取的 MRO (Method Resolution Order, 方法解析顺序) 的实现方式存在差异。</p>
<p>古典类是按照多继承申明的顺序形成继承树结构, 自顶向下采用深度优先的搜索顺序. 而新式类采用的是 C3 MRO 搜索方法, 在新式类通过__mro__得到 MRO 的搜索顺序, C3 MRO 的算法描述如下:</p>
<blockquote>
<p>假定，C1C2…CN 表示类 C1 到 CN 的序列，其中序列头部元素（head）=C1，序列尾部（tail）定义 = C2…CN；</p>
<p>C 继承的基类自左向右分别表示为 B1，B2…BN</p>
<p>L[C] 表示 C 的线性继承关系，其中 L[object] = object。</p>
<p>算法具体过程如下：</p>
<p>L[C(B1…BN)] = C + merge(L[B1] … L[BN], B1 … BN)</p>
<p>其中 merge 方法的计算规则如下：在 L[B1]…L[BN]，B1…BN 中，取 L[B1] 的 head，如果该元素不在 L[B2]…L[BN]，B1…BN 的尾部序列中，则添加该元素到 C 的线性继承序列中，同时将该元素从所有列表中删除（该头元素也叫 good head），否则取 L[B2] 的 head。继续相同的判断，直到整个列表为空或者没有办法找到任何符合要求的头元素（此时，将引发一个异常）。</p>
</blockquote>
<p>菱形继承是我们在多继承设计的时候需要尽量避免的一个问题。</p>
<h3 id="建议-59-理解描述符机制">建议 59: 理解描述符机制</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">   ...:     class_attr = <span class="number">1</span></div><div class="line">   ...:     </div><div class="line"><span class="comment"># 每一个类都有一个__dict__属性, 包含它的所有属性</span></div><div class="line">In [<span class="number">2</span>]: MyClass.__dict__</div><div class="line">Out[<span class="number">2</span>]:</div><div class="line">mappingproxy(&#123;<span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'MyClass'</span> objects&gt;,</div><div class="line">              <span class="string">'__doc__'</span>: <span class="keyword">None</span>,</div><div class="line">              <span class="string">'__module__'</span>: <span class="string">'__main__'</span>,</div><div class="line">              <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'MyClass'</span> objects&gt;,</div><div class="line">              <span class="string">'class_attr'</span>: <span class="number">1</span>&#125;)</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: my_instance = MyClass()</div><div class="line"><span class="comment"># 每一个实例也相应有一个实例属性, 我们通过实例访问一个属性时,</span></div><div class="line"><span class="comment"># 它首先会尝试在实例属性中查找, 找不到会到类属性中查找</span></div><div class="line">In [<span class="number">4</span>]: my_instance.__dict__</div><div class="line">Out[<span class="number">4</span>]: &#123;&#125;</div><div class="line"><span class="comment"># 实例访问类属性</span></div><div class="line">In [<span class="number">5</span>]: my_instance.class_attr</div><div class="line">Out[<span class="number">5</span>]: <span class="number">1</span></div><div class="line"><span class="comment"># 如果通过实例增加一个属性,只能改变此实例的属性</span></div><div class="line">In [<span class="number">6</span>]: my_instance.inst_attr = <span class="string">'china'</span></div><div class="line"></div><div class="line">In [<span class="number">7</span>]: my_instance.__dict__</div><div class="line">Out[<span class="number">7</span>]: &#123;<span class="string">'inst_attr'</span>: <span class="string">'china'</span>&#125;</div><div class="line"><span class="comment"># 对于类属性而言并没有丝毫变化</span></div><div class="line">In [<span class="number">8</span>]: MyClass.__dict__</div><div class="line">Out[<span class="number">8</span>]:</div><div class="line">mappingproxy(&#123;<span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'MyClass'</span> objects&gt;,</div><div class="line">              <span class="string">'__doc__'</span>: <span class="keyword">None</span>,</div><div class="line">              <span class="string">'__module__'</span>: <span class="string">'__main__'</span>,</div><div class="line">              <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'MyClass'</span> objects&gt;,</div><div class="line">              <span class="string">'class_attr'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="comment"># 我们可以动态地给类增加一个属性</span></div><div class="line">In [<span class="number">9</span>]: MyClass.class_attr2 = <span class="number">100</span></div><div class="line"></div><div class="line">In [<span class="number">10</span>]: my_instance.class_attr2</div><div class="line">Out[<span class="number">10</span>]: <span class="number">100</span></div><div class="line"><span class="comment"># 但Python的内置类型并不能随意地为它增加属性或方法</span></div></pre></td></tr></table></figure>
<p>.操作符封装了对实例属性和类属性两种不同属性进行查找的细节。</p>
<p>但是如果是访问方法呢:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">my_method</span><span class="params">(self)</span>:</span></div><div class="line">   ...:         print(<span class="string">'my_method'</span>)</div><div class="line">   ...:         </div><div class="line"></div><div class="line">In [<span class="number">2</span>]: MyClass.__dict__[<span class="string">'my_method'</span>]</div><div class="line">Out[<span class="number">2</span>]: &lt;function __main__.MyClass.my_method&gt;</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: MyClass.my_method</div><div class="line">Out[<span class="number">3</span>]: &lt;function __main__.MyClass.my_method&gt;</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: type(MyClass.my_method)</div><div class="line">Out[<span class="number">4</span>]: function</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: type(MyClass.__dict__[<span class="string">'my_method'</span>])</div><div class="line">Out[<span class="number">5</span>]: function</div></pre></td></tr></table></figure>
<p>根据通过实例访问属性和根据类访问属性的不同，有以下两种情况：</p>
<ul>
<li><p>一种是通过实例访问，比如代码 obj.x，如果 x 是一个描述符，那么 <strong>getattribute</strong>() 会返回 type(obj).<strong>dict</strong>[‘x’].<strong>get</strong>(obj, type(obj)) 结果，即：type(obj) 获取 obj 的类型；type(obj).<strong>dict</strong>[‘x’] 返回的是一个描述符，这里有一个试探和判断的过程；最后调用这个描述符的 <strong>get</strong>() 方法。</p></li>
<li><p>另一个是通过类访问的情况，比如代码 cls.x，则会被 <strong>getattribute</strong>()转换为 cls.<strong>dict</strong>[‘x’].<strong>get</strong>(None, cls)。</p>
<p>描述符协议是一个 Duck Typing 的协议，而每一个函数都有 <strong>get</strong> 方法，也就是说其他每一个函数都是描述符。所有对属性, 方法进行修饰的方案往往都用到了描述符, 如classmethod, staticmethod, property等, 以下是property的参考实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"Emulate PyProperty_Type() in Objects/descrobject.c"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></div><div class="line">        self.fget = fget</div><div class="line">        self.fset = fset</div><div class="line">        self.fdel = fdel</div><div class="line">        self.__doc__ = doc</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"unreadable attribute"</span></div><div class="line">        <span class="keyword">return</span> self.fget(obj)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't set attribute"</span></div><div class="line">        self.fset(obj, value)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't delete attribute"</span></div><div class="line">        self.fdel(obj)</div></pre></td></tr></table></figure></li>
</ul>
<h3 id="建议-60区别__getattr__和__getattribute__方法">建议 60：区别__getattr__()和__getattribute__()方法</h3>
<p>以上两种方法可以对实例属性进行获取和拦截：</p>
<ul>
<li><strong>getattr</strong>(self, name)：适用于属性在实例中以及对应的类的基类以及祖先类中都不存在；<br>
</li>
<li><strong>getattribute</strong>(self, name)：对于所有属性的访问都会调用该方法。</li>
</ul>
<p>但访问不存在的实例属性时，会由内部方法__getattribute__()抛出一个 AttributeError 异常，也就是说只要涉及实例属性的访问就会调用该方法，它要么返回实际的值，要么抛出异常。详情请<a href="http://link.zhihu.com/?target=http%3A//docs.python.org/2/reference/datamodel.html%23object.getattribute" target="_blank" rel="external">参考</a>。</p>
<p>那么__getattr__()在什么时候调用呢：</p>
<ul>
<li>属性不在实例的__dict__中；<br>
</li>
<li>属性不在其基类以及祖先类的__dict__中；<br>
</li>
<li>触发AttributeError异常时（注意，不仅仅是__getattribute__()方法的AttributeError异常，property 中定义的get()方法抛出异常的时候也会调用该方法）。</li>
</ul>
<p>当这两个方法同时被定义的时候，要么在__getattribute__()中显式调用，要么触发AttributeError异常，否则__getattr__()永远不会被调用。</p>
<p>我们知道 property 也能控制属性的访问，如果一个类中如果定义了 property、<strong>getattribute</strong>()以及__getattr__()来对属性进行访问控制，会最先搜索__getattribute__()方法，由于 property 对象并不存在于 dict 中，因此并不能返回该方法，此时会搜索 property 中的get()方法；当 property 中的set()方法对属性进行修改并再次访问 property 的get()方法会抛出异常，这时会触发__getattr__()的调用。</p>
<blockquote>
<p><strong>getattribute</strong>()总会被调用，而__getattr__()只有在__getattribute__()中引发异常的情况下调用。</p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/26/改善 Python 程序的 91 个建议读书笔记 2/" rel="next" title="改善 Python 程序的 91 个建议读书笔记 2">
                <i class="fa fa-chevron-left"></i> 改善 Python 程序的 91 个建议读书笔记 2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/18/机器学习实战读书笔记 -- 朴素贝叶斯/" rel="prev" title="机器学习实战读书笔记 -- 朴素贝叶斯">
                机器学习实战读书笔记 -- 朴素贝叶斯 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ww3.sinaimg.cn/large/646083e8jw1e4k8rg9xhdj20ai0am3z6.jpg"
               alt="王子子" />
          <p class="site-author-name" itemprop="name">王子子</p>
          <p class="site-description motion-element" itemprop="description">天生极客</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/heavysheep/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/wang-zi-zi-81-12/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Friends
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://andrewwang79.github.io" title="andrewwang" target="_blank">andrewwang</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-41使用argparse处理命令行参数"><span class="nav-number">1.</span> <span class="nav-text">建议 41：使用argparse处理命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-42使用pandas处理大型csv文件"><span class="nav-number">2.</span> <span class="nav-text">建议 42：使用pandas处理大型CSV文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-43一般情况下使用elementtree解析xml格式文件"><span class="nav-number">3.</span> <span class="nav-text">建议 43：一般情况下使用ElementTree解析xml格式文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-44理解模块pickle优劣"><span class="nav-number">4.</span> <span class="nav-text">建议 44：理解模块pickle优劣</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-53用状态模式美化代码"><span class="nav-number">5.</span> <span class="nav-text">建议 53：用状态模式美化代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-6-章-内部机制"><span class="nav-number"></span> <span class="nav-text">第 6 章 内部机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-54理解-built-in-objects"><span class="nav-number">1.</span> <span class="nav-text">建议 54：理解 built-in objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-55init不是构造方法"><span class="nav-number">2.</span> <span class="nav-text">建议 55：init()不是构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-56理解名字查找机制"><span class="nav-number">3.</span> <span class="nav-text">建议 56：理解名字查找机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-57-为什么需要-self-参数"><span class="nav-number">4.</span> <span class="nav-text">建议 57: 为什么需要 self 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-58-理解-mro-与多继承"><span class="nav-number">5.</span> <span class="nav-text">建议 58: 理解 MRO 与多继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-59-理解描述符机制"><span class="nav-number">6.</span> <span class="nav-text">建议 59: 理解描述符机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议-60区别__getattr__和__getattribute__方法"><span class="nav-number">7.</span> <span class="nav-text">建议 60：区别__getattr__()和__getattribute__()方法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王子子</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

  


</body>
</html>
